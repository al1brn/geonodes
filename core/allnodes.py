# Static classes exposing all nodes
#
# Auto generated by NodeInfo.gen_static_classes
# Blender version: (4, 3, 0)

import numpy as np
import bpy
from .treeclass import Node, ColorRamp
from .utils import get_object

class CommonStatic:
    @classmethod
    def frame(cls, label_size=20, shrink=True, text=None):
        """ > Node <&ShaderNode Frame>

        [&SHADER]

        Arguments
        ---------
        - label_size (int): parameter 'label_size'
        - shrink (bool): parameter 'shrink'
        - text (NoneType): parameter 'text'

        Returns
        -------
        - Node : 'Frame'
        """
        node = Node('Frame', label_size=label_size, shrink=shrink, text=text)
        return node


    @classmethod
    @property
    def group_input(cls):
        """ > Node <&ShaderNode Group Input>

        [&SHADER]

        Returns
        -------
        - None
        """
        node = Node('Group Input')
        return node._out


    @classmethod
    def group_output(cls, is_active_output=True):
        """ > Node <&ShaderNode Group Output>

        [&SHADER]

        Arguments
        ---------
        - is_active_output (bool): parameter 'is_active_output'

        Returns
        -------
        - Node : 'Group Output'
        """
        node = Node('Group Output', is_active_output=is_active_output)
        return node


    @classmethod
    def reroute(cls, input=None, socket_idname='NodeSocketColor'):
        """ > Node <&ShaderNode Reroute>

        [&SHADER]

        Arguments
        ---------
        - input (Color) : socket 'Input'
        - socket_idname (str): parameter 'socket_idname'

        Returns
        -------
        - Color
        """
        node = Node('Reroute', {'Input': input}, socket_idname=socket_idname)
        return node._out


    @classmethod
    def blackbody(cls, temperature=None):
        """ > Node <&ShaderNode Blackbody>

        [&SHADER]

        Arguments
        ---------
        - temperature (Float) : socket 'Temperature'

        Returns
        -------
        - Color
        """
        node = Node('Blackbody', {'Temperature': temperature})
        return node._out


    @classmethod
    def clamp(cls, value=None, min=None, max=None, clamp_type='MINMAX'):
        """ > Node <&ShaderNode Clamp>

        [&SHADER]

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - min (Float) : socket 'Min'
        - max (Float) : socket 'Max'
        - clamp_type (str): parameter 'clamp_type' in ('MINMAX', 'RANGE')

        Returns
        -------
        - Float
        """
        node = Node('Clamp', {'Value': value, 'Min': min, 'Max': max}, clamp_type=clamp_type)
        return node._out


    @classmethod
    def combine_xyz(cls, x=None, y=None, z=None):
        """ > Node <&ShaderNode Combine XYZ>

        [&SHADER]

        Arguments
        ---------
        - x (Float) : socket 'X'
        - y (Float) : socket 'Y'
        - z (Float) : socket 'Z'

        Returns
        -------
        - Vector
        """
        node = Node('Combine XYZ', {'X': x, 'Y': y, 'Z': z})
        return node._out


    @classmethod
    def float_curve(cls, factor=None, value=None, mapping=None):
        """ > Node <&ShaderNode Float Curve>

        [&SHADER]

        Arguments
        ---------
        - factor (Float) : socket 'Factor'
        - value (Float) : socket 'Value'
        - mapping (CurveMapping): parameter 'mapping'

        Returns
        -------
        - Float
        """
        node = Node('Float Curve', {'Factor': factor, 'Value': value}, mapping=mapping)
        return node._out


    @classmethod
    def map_range(cls, value=None, from_min=None, from_max=None, to_min=None, to_max=None, steps=None, steps_1=None, vector=None, clamp=True, data_type='FLOAT', interpolation_type='LINEAR'):
        """ > Node <&ShaderNode Map Range>

        [&SHADER]

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - from_min (Float) : socket 'From Min'
        - from_max (Float) : socket 'From Max'
        - to_min (Float) : socket 'To Min'
        - to_max (Float) : socket 'To Max'
        - steps (Float) : socket 'Steps'
        - steps_1 (Vector) : socket 'Steps' (id: 'Steps_FLOAT3')
        - vector (Vector) : socket 'Vector'
        - clamp (bool): parameter 'clamp'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'FLOAT_VECTOR')
        - interpolation_type (str): parameter 'interpolation_type' in ('LINEAR', 'STEPPED', 'SMOOTHSTEP', 'SMOOTHERSTEP')

        Returns
        -------
        - Node : 'Map Range'
        """
        node = Node('Map Range', {'Value': value, 'From Min': from_min, 'From Max': from_max, 'To Min': to_min, 'To Max': to_max, 'Steps': steps, 'Steps_FLOAT3': steps_1, 'Vector': vector}, clamp=clamp, data_type=data_type, interpolation_type=interpolation_type)
        return node


    @classmethod
    def math(cls, value=None, value_1=None, value_2=None, operation='ADD', use_clamp=False):
        """ > Node <&ShaderNode Math>

        [&SHADER]

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - value_1 (Float) : socket 'Value' (id: 'Value_001')
        - value_2 (Float) : socket 'Value' (id: 'Value_002')
        - operation (str): parameter 'operation' in ('ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE', 'MULTIPLY_ADD', 'POWER', 'LOGARITHM', 'SQRT', 'INVERSE_SQRT', 'ABSOLUTE', 'EXPONENT', 'MINIMUM', 'MAXIMUM', 'LESS_THAN', 'GREATER_THAN', 'SIGN', 'COMPARE', 'SMOOTH_MIN', 'SMOOTH_MAX', 'ROUND', 'FLOOR', 'CEIL', 'TRUNC', 'FRACT', 'MODULO', 'FLOORED_MODULO', 'WRAP', 'SNAP', 'PINGPONG', 'SINE', 'COSINE', 'TANGENT', 'ARCSINE', 'ARCCOSINE', 'ARCTANGENT', 'ARCTAN2', 'SINH', 'COSH', 'TANH', 'RADIANS', 'DEGREES')
        - use_clamp (bool): parameter 'use_clamp'

        Returns
        -------
        - Float
        """
        node = Node('Math', {'Value': value, 'Value_001': value_1, 'Value_002': value_2}, operation=operation, use_clamp=use_clamp)
        return node._out


    @classmethod
    def mix(cls, factor=None, a=None, b=None, blend_type='MIX', clamp_factor=True, clamp_result=False, data_type='FLOAT', factor_mode='UNIFORM'):
        """ > Node <&ShaderNode Mix>

        [&SHADER]

        Arguments
        ---------
        - factor (Float) : socket 'Factor'
        - a (Float) : socket 'A'
        - b (Float) : socket 'B'
        - blend_type (str): parameter 'blend_type' in ('MIX', 'DARKEN', 'MULTIPLY', 'BURN', 'LIGHTEN', 'SCREEN', 'DODGE', 'ADD', 'OVERLAY', 'SOFT_LIGHT', 'LINEAR_LIGHT', 'DIFFERENCE', 'EXCLUSION', 'SUBTRACT', 'DIVIDE', 'HUE', 'SATURATION', 'COLOR', 'VALUE')
        - clamp_factor (bool): parameter 'clamp_factor'
        - clamp_result (bool): parameter 'clamp_result'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'VECTOR', 'RGBA')
        - factor_mode (str): parameter 'factor_mode' in ('UNIFORM', 'NON_UNIFORM')

        Returns
        -------
        - Node : 'Mix'
        """
        node = Node('Mix', {'Factor': factor, 'A': a, 'B': b}, blend_type=blend_type, clamp_factor=clamp_factor, clamp_result=clamp_result, data_type=data_type, factor_mode=factor_mode)
        return node


    @classmethod
    def rgb_curves(cls, fac=None, color=None, mapping=None):
        """ > Node <&ShaderNode RGB Curves>

        [&SHADER]

        Arguments
        ---------
        - fac (Float) : socket 'Fac'
        - color (Color) : socket 'Color'
        - mapping (CurveMapping): parameter 'mapping'

        Returns
        -------
        - Color
        """
        node = Node('RGB Curves', {'Fac': fac, 'Color': color}, mapping=mapping)
        return node._out


    @classmethod
    def separate_xyz(cls, vector=None):
        """ > Node <&ShaderNode Separate XYZ>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'

        Returns
        -------
        - Node : 'Separate XYZ'
        """
        node = Node('Separate XYZ', {'Vector': vector})
        return node


    @classmethod
    def brick_texture(cls, vector=None, color1=None, color2=None, mortar=None, scale=None, mortar_size=None, mortar_smooth=None, bias=None, brick_width=None, row_height=None, color_mapping=None, offset=0.5, offset_frequency=2, squash=1.0, squash_frequency=2, texture_mapping=None):
        """ > Node <&ShaderNode Brick Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - color1 (Color) : socket 'Color1'
        - color2 (Color) : socket 'Color2'
        - mortar (Color) : socket 'Mortar'
        - scale (Float) : socket 'Scale'
        - mortar_size (Float) : socket 'Mortar Size'
        - mortar_smooth (Float) : socket 'Mortar Smooth'
        - bias (Float) : socket 'Bias'
        - brick_width (Float) : socket 'Brick Width'
        - row_height (Float) : socket 'Row Height'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - offset (float): parameter 'offset'
        - offset_frequency (int): parameter 'offset_frequency'
        - squash (float): parameter 'squash'
        - squash_frequency (int): parameter 'squash_frequency'
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Node : 'Brick Texture'
        """
        node = Node('Brick Texture', {'Vector': vector, 'Color1': color1, 'Color2': color2, 'Mortar': mortar, 'Scale': scale, 'Mortar Size': mortar_size, 'Mortar Smooth': mortar_smooth, 'Bias': bias, 'Brick Width': brick_width, 'Row Height': row_height}, color_mapping=color_mapping, offset=offset, offset_frequency=offset_frequency, squash=squash, squash_frequency=squash_frequency, texture_mapping=texture_mapping)
        return node


    @classmethod
    def checker_texture(cls, vector=None, color1=None, color2=None, scale=None, color_mapping=None, texture_mapping=None):
        """ > Node <&ShaderNode Checker Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - color1 (Color) : socket 'Color1'
        - color2 (Color) : socket 'Color2'
        - scale (Float) : socket 'Scale'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Node : 'Checker Texture'
        """
        node = Node('Checker Texture', {'Vector': vector, 'Color1': color1, 'Color2': color2, 'Scale': scale}, color_mapping=color_mapping, texture_mapping=texture_mapping)
        return node


    @classmethod
    def gabor_texture(cls, vector=None, scale=None, frequency=None, anisotropy=None, orientation=None, color_mapping=None, gabor_type='2D', texture_mapping=None):
        """ > Node <&ShaderNode Gabor Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - scale (Float) : socket 'Scale'
        - frequency (Float) : socket 'Frequency'
        - anisotropy (Float) : socket 'Anisotropy'
        - orientation (Float) : socket 'Orientation'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - gabor_type (str): parameter 'gabor_type' in ('2D', '3D')
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Node : 'Gabor Texture'
        """
        node = Node('Gabor Texture', {'Vector': vector, 'Scale': scale, 'Frequency': frequency, 'Anisotropy': anisotropy, 'Orientation': orientation}, color_mapping=color_mapping, gabor_type=gabor_type, texture_mapping=texture_mapping)
        return node


    @classmethod
    def gradient_texture(cls, vector=None, color_mapping=None, gradient_type='LINEAR', texture_mapping=None):
        """ > Node <&ShaderNode Gradient Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - gradient_type (str): parameter 'gradient_type' in ('LINEAR', 'QUADRATIC', 'EASING', 'DIAGONAL', 'SPHERICAL', 'QUADRATIC_SPHERE', 'RADIAL')
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Node : 'Gradient Texture'
        """
        node = Node('Gradient Texture', {'Vector': vector}, color_mapping=color_mapping, gradient_type=gradient_type, texture_mapping=texture_mapping)
        return node


    @classmethod
    def magic_texture(cls, vector=None, scale=None, distortion=None, color_mapping=None, texture_mapping=None, turbulence_depth=2):
        """ > Node <&ShaderNode Magic Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - scale (Float) : socket 'Scale'
        - distortion (Float) : socket 'Distortion'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - texture_mapping (TexMapping): parameter 'texture_mapping'
        - turbulence_depth (int): parameter 'turbulence_depth'

        Returns
        -------
        - Node : 'Magic Texture'
        """
        node = Node('Magic Texture', {'Vector': vector, 'Scale': scale, 'Distortion': distortion}, color_mapping=color_mapping, texture_mapping=texture_mapping, turbulence_depth=turbulence_depth)
        return node


    @classmethod
    def noise_texture(cls, vector=None, w=None, scale=None, detail=None, roughness=None, lacunarity=None, offset=None, gain=None, distortion=None, color_mapping=None, noise_dimensions='3D', noise_type='FBM', normalize=True, texture_mapping=None):
        """ > Node <&ShaderNode Noise Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - w (Float) : socket 'W'
        - scale (Float) : socket 'Scale'
        - detail (Float) : socket 'Detail'
        - roughness (Float) : socket 'Roughness'
        - lacunarity (Float) : socket 'Lacunarity'
        - offset (Float) : socket 'Offset'
        - gain (Float) : socket 'Gain'
        - distortion (Float) : socket 'Distortion'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - noise_dimensions (str): parameter 'noise_dimensions' in ('1D', '2D', '3D', '4D')
        - noise_type (str): parameter 'noise_type' in ('MULTIFRACTAL', 'RIDGED_MULTIFRACTAL', 'HYBRID_MULTIFRACTAL', 'FBM', 'HETERO_TERRAIN')
        - normalize (bool): parameter 'normalize'
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Node : 'Noise Texture'
        """
        node = Node('Noise Texture', {'Vector': vector, 'W': w, 'Scale': scale, 'Detail': detail, 'Roughness': roughness, 'Lacunarity': lacunarity, 'Offset': offset, 'Gain': gain, 'Distortion': distortion}, color_mapping=color_mapping, noise_dimensions=noise_dimensions, noise_type=noise_type, normalize=normalize, texture_mapping=texture_mapping)
        return node


    @classmethod
    def voronoi_texture(cls, vector=None, w=None, scale=None, detail=None, roughness=None, lacunarity=None, smoothness=None, exponent=None, randomness=None, color_mapping=None, distance='EUCLIDEAN', feature='F1', normalize=False, texture_mapping=None, voronoi_dimensions='3D'):
        """ > Node <&ShaderNode Voronoi Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - w (Float) : socket 'W'
        - scale (Float) : socket 'Scale'
        - detail (Float) : socket 'Detail'
        - roughness (Float) : socket 'Roughness'
        - lacunarity (Float) : socket 'Lacunarity'
        - smoothness (Float) : socket 'Smoothness'
        - exponent (Float) : socket 'Exponent'
        - randomness (Float) : socket 'Randomness'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - distance (str): parameter 'distance' in ('EUCLIDEAN', 'MANHATTAN', 'CHEBYCHEV', 'MINKOWSKI')
        - feature (str): parameter 'feature' in ('F1', 'F2', 'SMOOTH_F1', 'DISTANCE_TO_EDGE', 'N_SPHERE_RADIUS')
        - normalize (bool): parameter 'normalize'
        - texture_mapping (TexMapping): parameter 'texture_mapping'
        - voronoi_dimensions (str): parameter 'voronoi_dimensions' in ('1D', '2D', '3D', '4D')

        Returns
        -------
        - Node : 'Voronoi Texture'
        """
        node = Node('Voronoi Texture', {'Vector': vector, 'W': w, 'Scale': scale, 'Detail': detail, 'Roughness': roughness, 'Lacunarity': lacunarity, 'Smoothness': smoothness, 'Exponent': exponent, 'Randomness': randomness}, color_mapping=color_mapping, distance=distance, feature=feature, normalize=normalize, texture_mapping=texture_mapping, voronoi_dimensions=voronoi_dimensions)
        return node


    @classmethod
    def wave_texture(cls, vector=None, scale=None, distortion=None, detail=None, detail_scale=None, detail_roughness=None, phase_offset=None, bands_direction='X', color_mapping=None, rings_direction='X', texture_mapping=None, wave_profile='SIN', wave_type='BANDS'):
        """ > Node <&ShaderNode Wave Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - scale (Float) : socket 'Scale'
        - distortion (Float) : socket 'Distortion'
        - detail (Float) : socket 'Detail'
        - detail_scale (Float) : socket 'Detail Scale'
        - detail_roughness (Float) : socket 'Detail Roughness'
        - phase_offset (Float) : socket 'Phase Offset'
        - bands_direction (str): parameter 'bands_direction' in ('X', 'Y', 'Z', 'DIAGONAL')
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - rings_direction (str): parameter 'rings_direction' in ('X', 'Y', 'Z', 'SPHERICAL')
        - texture_mapping (TexMapping): parameter 'texture_mapping'
        - wave_profile (str): parameter 'wave_profile' in ('SIN', 'SAW', 'TRI')
        - wave_type (str): parameter 'wave_type' in ('BANDS', 'RINGS')

        Returns
        -------
        - Node : 'Wave Texture'
        """
        node = Node('Wave Texture', {'Vector': vector, 'Scale': scale, 'Distortion': distortion, 'Detail': detail, 'Detail Scale': detail_scale, 'Detail Roughness': detail_roughness, 'Phase Offset': phase_offset}, bands_direction=bands_direction, color_mapping=color_mapping, rings_direction=rings_direction, texture_mapping=texture_mapping, wave_profile=wave_profile, wave_type=wave_type)
        return node


    @classmethod
    def white_noise_texture(cls, vector=None, w=None, noise_dimensions='3D'):
        """ > Node <&ShaderNode White Noise Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - w (Float) : socket 'W'
        - noise_dimensions (str): parameter 'noise_dimensions' in ('1D', '2D', '3D', '4D')

        Returns
        -------
        - Node : 'White Noise Texture'
        """
        node = Node('White Noise Texture', {'Vector': vector, 'W': w}, noise_dimensions=noise_dimensions)
        return node


    @classmethod
    def color_ramp(cls, fac=None, stops=[]):
        """ > Node <&ShaderNode Color Ramp>

        [&SHADER]

        Arguments
        ---------
        - fac (Float) : socket 'Fac'
        - stops (list): parameter 'stops'

        Returns
        -------
        - Node : 'Color Ramp'
        """
        node = ColorRamp(fac=fac, stops=stops)
        return node


    @classmethod
    @property
    def value(cls):
        """ > Node <&ShaderNode Value>

        [&SHADER]

        Returns
        -------
        - Float
        """
        node = Node('Value')
        return node._out


    @classmethod
    def vector_curves(cls, fac=None, vector=None, mapping=None):
        """ > Node <&ShaderNode Vector Curves>

        [&SHADER]

        Arguments
        ---------
        - fac (Float) : socket 'Fac'
        - vector (Vector) : socket 'Vector'
        - mapping (CurveMapping): parameter 'mapping'

        Returns
        -------
        - Vector
        """
        node = Node('Vector Curves', {'Fac': fac, 'Vector': vector}, mapping=mapping)
        return node._out


    @classmethod
    def vector_math(cls, vector=None, vector_1=None, vector_2=None, scale=None, operation='ADD'):
        """ > Node <&ShaderNode Vector Math>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - vector_1 (Vector) : socket 'Vector' (id: 'Vector_001')
        - vector_2 (Vector) : socket 'Vector' (id: 'Vector_002')
        - scale (Float) : socket 'Scale'
        - operation (str): parameter 'operation' in ('ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE', 'MULTIPLY_ADD', 'CROSS_PRODUCT', 'PROJECT', 'REFLECT', 'REFRACT', 'FACEFORWARD', 'DOT_PRODUCT', 'DISTANCE', 'LENGTH', 'SCALE', 'NORMALIZE', 'ABSOLUTE', 'MINIMUM', 'MAXIMUM', 'FLOOR', 'CEIL', 'FRACTION', 'MODULO', 'WRAP', 'SNAP', 'SINE', 'COSINE', 'TANGENT')

        Returns
        -------
        - Node : 'Vector Math'
        """
        node = Node('Vector Math', {'Vector': vector, 'Vector_001': vector_1, 'Vector_002': vector_2, 'Scale': scale}, operation=operation)
        return node


    @classmethod
    def vector_rotate(cls, vector=None, center=None, axis=None, angle=None, rotation=None, invert=False, rotation_type='AXIS_ANGLE'):
        """ > Node <&ShaderNode Vector Rotate>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - center (Vector) : socket 'Center'
        - axis (Vector) : socket 'Axis'
        - angle (Float) : socket 'Angle'
        - rotation (Vector) : socket 'Rotation'
        - invert (bool): parameter 'invert'
        - rotation_type (str): parameter 'rotation_type' in ('AXIS_ANGLE', 'X_AXIS', 'Y_AXIS', 'Z_AXIS', 'EULER_XYZ')

        Returns
        -------
        - Vector
        """
        node = Node('Vector Rotate', {'Vector': vector, 'Center': center, 'Axis': axis, 'Angle': angle, 'Rotation': rotation}, invert=invert, rotation_type=rotation_type)
        return node._out


class snd(CommonStatic):
    @classmethod
    def add_shader(cls, shader=None, shader_1=None):
        """ > Node <&ShaderNode Add Shader>

        [&SHADER]

        Arguments
        ---------
        - shader (Shader) : socket 'Shader'
        - shader_1 (Shader) : socket 'Shader' (id: 'Shader_001')

        Returns
        -------
        - Shader
        """
        node = Node('Add Shader', {'Shader': shader, 'Shader_001': shader_1})
        return node._out


    @classmethod
    def ambient_occlusion(cls, color=None, distance=None, normal=None, inside=False, only_local=False, samples=16):
        """ > Node <&ShaderNode Ambient Occlusion>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - distance (Float) : socket 'Distance'
        - normal (Vector) : socket 'Normal'
        - inside (bool): parameter 'inside'
        - only_local (bool): parameter 'only_local'
        - samples (int): parameter 'samples'

        Returns
        -------
        - Node : 'Ambient Occlusion'
        """
        node = Node('Ambient Occlusion', {'Color': color, 'Distance': distance, 'Normal': normal}, inside=inside, only_local=only_local, samples=samples)
        return node


    @classmethod
    def attribute(cls, attribute_name='', attribute_type='GEOMETRY'):
        """ > Node <&ShaderNode Attribute>

        [&SHADER]

        Arguments
        ---------
        - attribute_name (str): parameter 'attribute_name'
        - attribute_type (str): parameter 'attribute_type' in ('GEOMETRY', 'OBJECT', 'INSTANCER', 'VIEW_LAYER')

        Returns
        -------
        - Node : 'Attribute'
        """
        node = Node('Attribute', attribute_name=attribute_name, attribute_type=attribute_type)
        return node


    @classmethod
    def background(cls, color=None, strength=None, weight=None):
        """ > Node <&ShaderNode Background>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - strength (Float) : socket 'Strength'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Background', {'Color': color, 'Strength': strength, 'Weight': weight})
        return node._out


    @classmethod
    def bevel(cls, radius=None, normal=None, samples=4):
        """ > Node <&ShaderNode Bevel>

        [&SHADER]

        Arguments
        ---------
        - radius (Float) : socket 'Radius'
        - normal (Vector) : socket 'Normal'
        - samples (int): parameter 'samples'

        Returns
        -------
        - Vector
        """
        node = Node('Bevel', {'Radius': radius, 'Normal': normal}, samples=samples)
        return node._out


    @classmethod
    def brightness_contrast(cls, color=None, bright=None, contrast=None):
        """ > Node <&ShaderNode Brightness/Contrast>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - bright (Float) : socket 'Bright'
        - contrast (Float) : socket 'Contrast'

        Returns
        -------
        - Color
        """
        node = Node('Brightness/Contrast', {'Color': color, 'Bright': bright, 'Contrast': contrast})
        return node._out


    @classmethod
    def glossy_bsdf(cls, color=None, roughness=None, anisotropy=None, rotation=None, normal=None, tangent=None, weight=None, distribution='MULTI_GGX'):
        """ > Node <&ShaderNode Glossy BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - roughness (Float) : socket 'Roughness'
        - anisotropy (Float) : socket 'Anisotropy'
        - rotation (Float) : socket 'Rotation'
        - normal (Vector) : socket 'Normal'
        - tangent (Vector) : socket 'Tangent'
        - weight (Float) : socket 'Weight'
        - distribution (str): parameter 'distribution' in ('BECKMANN', 'GGX', 'ASHIKHMIN_SHIRLEY', 'MULTI_GGX')

        Returns
        -------
        - Shader
        """
        node = Node('Glossy BSDF', {'Color': color, 'Roughness': roughness, 'Anisotropy': anisotropy, 'Rotation': rotation, 'Normal': normal, 'Tangent': tangent, 'Weight': weight}, distribution=distribution)
        return node._out


    @classmethod
    def diffuse_bsdf(cls, color=None, roughness=None, normal=None, weight=None):
        """ > Node <&ShaderNode Diffuse BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - roughness (Float) : socket 'Roughness'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Diffuse BSDF', {'Color': color, 'Roughness': roughness, 'Normal': normal, 'Weight': weight})
        return node._out


    @classmethod
    def glass_bsdf(cls, color=None, roughness=None, ior=None, normal=None, weight=None, distribution='MULTI_GGX'):
        """ > Node <&ShaderNode Glass BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - roughness (Float) : socket 'Roughness'
        - ior (Float) : socket 'IOR'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'
        - distribution (str): parameter 'distribution' in ('BECKMANN', 'GGX', 'MULTI_GGX')

        Returns
        -------
        - Shader
        """
        node = Node('Glass BSDF', {'Color': color, 'Roughness': roughness, 'IOR': ior, 'Normal': normal, 'Weight': weight}, distribution=distribution)
        return node._out


    @classmethod
    def hair_bsdf(cls, color=None, offset=None, roughnessu=None, roughnessv=None, tangent=None, weight=None, component='Reflection'):
        """ > Node <&ShaderNode Hair BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - offset (Float) : socket 'Offset'
        - roughnessu (Float) : socket 'RoughnessU'
        - roughnessv (Float) : socket 'RoughnessV'
        - tangent (Vector) : socket 'Tangent'
        - weight (Float) : socket 'Weight'
        - component (str): parameter 'component' in ('Reflection', 'Transmission')

        Returns
        -------
        - Shader
        """
        node = Node('Hair BSDF', {'Color': color, 'Offset': offset, 'RoughnessU': roughnessu, 'RoughnessV': roughnessv, 'Tangent': tangent, 'Weight': weight}, component=component)
        return node._out


    @classmethod
    def principled_hair_bsdf(cls, color=None, melanin=None, melanin_redness=None, tint=None, absorption_coefficient=None, aspect_ratio=None, roughness=None, radial_roughness=None, coat=None, ior=None, offset=None, random_color=None, random_roughness=None, random=None, weight=None, reflection=None, transmission=None, secondary_reflection=None, model='CHIANG', parametrization='COLOR'):
        """ > Node <&ShaderNode Principled Hair BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - melanin (Float) : socket 'Melanin'
        - melanin_redness (Float) : socket 'Melanin Redness'
        - tint (Color) : socket 'Tint'
        - absorption_coefficient (Vector) : socket 'Absorption Coefficient'
        - aspect_ratio (Float) : socket 'Aspect Ratio'
        - roughness (Float) : socket 'Roughness'
        - radial_roughness (Float) : socket 'Radial Roughness'
        - coat (Float) : socket 'Coat'
        - ior (Float) : socket 'IOR'
        - offset (Float) : socket 'Offset'
        - random_color (Float) : socket 'Random Color'
        - random_roughness (Float) : socket 'Random Roughness'
        - random (Float) : socket 'Random'
        - weight (Float) : socket 'Weight'
        - reflection (Float) : socket 'Reflection'
        - transmission (Float) : socket 'Transmission'
        - secondary_reflection (Float) : socket 'Secondary Reflection'
        - model (str): parameter 'model' in ('CHIANG', 'HUANG')
        - parametrization (str): parameter 'parametrization' in ('ABSORPTION', 'MELANIN', 'COLOR')

        Returns
        -------
        - Shader
        """
        node = Node('Principled Hair BSDF', {'Color': color, 'Melanin': melanin, 'Melanin Redness': melanin_redness, 'Tint': tint, 'Absorption Coefficient': absorption_coefficient, 'Aspect Ratio': aspect_ratio, 'Roughness': roughness, 'Radial Roughness': radial_roughness, 'Coat': coat, 'IOR': ior, 'Offset': offset, 'Random Color': random_color, 'Random Roughness': random_roughness, 'Random': random, 'Weight': weight, 'Reflection': reflection, 'Transmission': transmission, 'Secondary Reflection': secondary_reflection}, model=model, parametrization=parametrization)
        return node._out


    @classmethod
    def metallic_bsdf(cls, base_color=None, edge_tint=None, ior=None, extinction=None, roughness=None, anisotropy=None, rotation=None, normal=None, tangent=None, weight=None, distribution='MULTI_GGX', fresnel_type='F82'):
        """ > Node <&ShaderNode Metallic BSDF>

        [&SHADER]

        Arguments
        ---------
        - base_color (Color) : socket 'Base Color'
        - edge_tint (Color) : socket 'Edge Tint'
        - ior (Vector) : socket 'IOR'
        - extinction (Vector) : socket 'Extinction'
        - roughness (Float) : socket 'Roughness'
        - anisotropy (Float) : socket 'Anisotropy'
        - rotation (Float) : socket 'Rotation'
        - normal (Vector) : socket 'Normal'
        - tangent (Vector) : socket 'Tangent'
        - weight (Float) : socket 'Weight'
        - distribution (str): parameter 'distribution' in ('BECKMANN', 'GGX', 'MULTI_GGX')
        - fresnel_type (str): parameter 'fresnel_type' in ('PHYSICAL_CONDUCTOR', 'F82')

        Returns
        -------
        - Shader
        """
        node = Node('Metallic BSDF', {'Base Color': base_color, 'Edge Tint': edge_tint, 'IOR': ior, 'Extinction': extinction, 'Roughness': roughness, 'Anisotropy': anisotropy, 'Rotation': rotation, 'Normal': normal, 'Tangent': tangent, 'Weight': weight}, distribution=distribution, fresnel_type=fresnel_type)
        return node._out


    @classmethod
    def principled_bsdf(cls, base_color=None, metallic=None, roughness=None, ior=None, alpha=None, normal=None, weight=None, diffuse_roughness=None, subsurface_weight=None, subsurface_radius=None, subsurface_scale=None, subsurface_ior=None, subsurface_anisotropy=None, specular_ior_level=None, specular_tint=None, anisotropic=None, anisotropic_rotation=None, tangent=None, transmission_weight=None, coat_weight=None, coat_roughness=None, coat_ior=None, coat_tint=None, coat_normal=None, sheen_weight=None, sheen_roughness=None, sheen_tint=None, emission_color=None, emission_strength=None, thin_film_thickness=None, thin_film_ior=None, distribution='MULTI_GGX', subsurface_method='RANDOM_WALK'):
        """ > Node <&ShaderNode Principled BSDF>

        [&SHADER]

        Arguments
        ---------
        - base_color (Color) : socket 'Base Color'
        - metallic (Float) : socket 'Metallic'
        - roughness (Float) : socket 'Roughness'
        - ior (Float) : socket 'IOR'
        - alpha (Float) : socket 'Alpha'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'
        - diffuse_roughness (Float) : socket 'Diffuse Roughness'
        - subsurface_weight (Float) : socket 'Subsurface Weight'
        - subsurface_radius (Vector) : socket 'Subsurface Radius'
        - subsurface_scale (Float) : socket 'Subsurface Scale'
        - subsurface_ior (Float) : socket 'Subsurface IOR'
        - subsurface_anisotropy (Float) : socket 'Subsurface Anisotropy'
        - specular_ior_level (Float) : socket 'Specular IOR Level'
        - specular_tint (Color) : socket 'Specular Tint'
        - anisotropic (Float) : socket 'Anisotropic'
        - anisotropic_rotation (Float) : socket 'Anisotropic Rotation'
        - tangent (Vector) : socket 'Tangent'
        - transmission_weight (Float) : socket 'Transmission Weight'
        - coat_weight (Float) : socket 'Coat Weight'
        - coat_roughness (Float) : socket 'Coat Roughness'
        - coat_ior (Float) : socket 'Coat IOR'
        - coat_tint (Color) : socket 'Coat Tint'
        - coat_normal (Vector) : socket 'Coat Normal'
        - sheen_weight (Float) : socket 'Sheen Weight'
        - sheen_roughness (Float) : socket 'Sheen Roughness'
        - sheen_tint (Color) : socket 'Sheen Tint'
        - emission_color (Color) : socket 'Emission Color'
        - emission_strength (Float) : socket 'Emission Strength'
        - thin_film_thickness (Float) : socket 'Thin Film Thickness'
        - thin_film_ior (Float) : socket 'Thin Film IOR'
        - distribution (str): parameter 'distribution' in ('GGX', 'MULTI_GGX')
        - subsurface_method (str): parameter 'subsurface_method' in ('BURLEY', 'RANDOM_WALK', 'RANDOM_WALK_SKIN')

        Returns
        -------
        - Shader
        """
        node = Node('Principled BSDF', {'Base Color': base_color, 'Metallic': metallic, 'Roughness': roughness, 'IOR': ior, 'Alpha': alpha, 'Normal': normal, 'Weight': weight, 'Diffuse Roughness': diffuse_roughness, 'Subsurface Weight': subsurface_weight, 'Subsurface Radius': subsurface_radius, 'Subsurface Scale': subsurface_scale, 'Subsurface IOR': subsurface_ior, 'Subsurface Anisotropy': subsurface_anisotropy, 'Specular IOR Level': specular_ior_level, 'Specular Tint': specular_tint, 'Anisotropic': anisotropic, 'Anisotropic Rotation': anisotropic_rotation, 'Tangent': tangent, 'Transmission Weight': transmission_weight, 'Coat Weight': coat_weight, 'Coat Roughness': coat_roughness, 'Coat IOR': coat_ior, 'Coat Tint': coat_tint, 'Coat Normal': coat_normal, 'Sheen Weight': sheen_weight, 'Sheen Roughness': sheen_roughness, 'Sheen Tint': sheen_tint, 'Emission Color': emission_color, 'Emission Strength': emission_strength, 'Thin Film Thickness': thin_film_thickness, 'Thin Film IOR': thin_film_ior}, distribution=distribution, subsurface_method=subsurface_method)
        return node._out


    @classmethod
    def ray_portal_bsdf(cls, color=None, position=None, direction=None, weight=None):
        """ > Node <&ShaderNode Ray Portal BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - position (Vector) : socket 'Position'
        - direction (Vector) : socket 'Direction'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Ray Portal BSDF', {'Color': color, 'Position': position, 'Direction': direction, 'Weight': weight})
        return node._out


    @classmethod
    def refraction_bsdf(cls, color=None, roughness=None, ior=None, normal=None, weight=None, distribution='BECKMANN'):
        """ > Node <&ShaderNode Refraction BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - roughness (Float) : socket 'Roughness'
        - ior (Float) : socket 'IOR'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'
        - distribution (str): parameter 'distribution' in ('BECKMANN', 'GGX')

        Returns
        -------
        - Shader
        """
        node = Node('Refraction BSDF', {'Color': color, 'Roughness': roughness, 'IOR': ior, 'Normal': normal, 'Weight': weight}, distribution=distribution)
        return node._out


    @classmethod
    def sheen_bsdf(cls, color=None, roughness=None, normal=None, weight=None, distribution='MICROFIBER'):
        """ > Node <&ShaderNode Sheen BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - roughness (Float) : socket 'Roughness'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'
        - distribution (str): parameter 'distribution' in ('ASHIKHMIN', 'MICROFIBER')

        Returns
        -------
        - Shader
        """
        node = Node('Sheen BSDF', {'Color': color, 'Roughness': roughness, 'Normal': normal, 'Weight': weight}, distribution=distribution)
        return node._out


    @classmethod
    def toon_bsdf(cls, color=None, size=None, smooth=None, normal=None, weight=None, component='DIFFUSE'):
        """ > Node <&ShaderNode Toon BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - size (Float) : socket 'Size'
        - smooth (Float) : socket 'Smooth'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'
        - component (str): parameter 'component' in ('DIFFUSE', 'GLOSSY')

        Returns
        -------
        - Shader
        """
        node = Node('Toon BSDF', {'Color': color, 'Size': size, 'Smooth': smooth, 'Normal': normal, 'Weight': weight}, component=component)
        return node._out


    @classmethod
    def translucent_bsdf(cls, color=None, normal=None, weight=None):
        """ > Node <&ShaderNode Translucent BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Translucent BSDF', {'Color': color, 'Normal': normal, 'Weight': weight})
        return node._out


    @classmethod
    def transparent_bsdf(cls, color=None, weight=None):
        """ > Node <&ShaderNode Transparent BSDF>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Transparent BSDF', {'Color': color, 'Weight': weight})
        return node._out


    @classmethod
    def bump(cls, strength=None, distance=None, height=None, normal=None, invert=False):
        """ > Node <&ShaderNode Bump>

        [&SHADER]

        Arguments
        ---------
        - strength (Float) : socket 'Strength'
        - distance (Float) : socket 'Distance'
        - height (Float) : socket 'Height'
        - normal (Vector) : socket 'Normal'
        - invert (bool): parameter 'invert'

        Returns
        -------
        - Vector
        """
        node = Node('Bump', {'Strength': strength, 'Distance': distance, 'Height': height, 'Normal': normal}, invert=invert)
        return node._out


    @classmethod
    @property
    def camera_data(cls):
        """ > Node <&ShaderNode Camera Data>

        [&SHADER]

        Returns
        -------
        - Node : 'Camera Data'
        """
        node = Node('Camera Data')
        return node


    @classmethod
    def combine_color(cls, red=None, green=None, blue=None, mode='RGB'):
        """ > Node <&ShaderNode Combine Color>

        [&SHADER]

        Arguments
        ---------
        - red (Float) : socket 'Red'
        - green (Float) : socket 'Green'
        - blue (Float) : socket 'Blue'
        - mode (str): parameter 'mode' in ('RGB', 'HSV', 'HSL')

        Returns
        -------
        - Color
        """
        node = Node('Combine Color', {'Red': red, 'Green': green, 'Blue': blue}, mode=mode)
        return node._out


    @classmethod
    def displacement(cls, height=None, midlevel=None, scale=None, normal=None, space='OBJECT'):
        """ > Node <&ShaderNode Displacement>

        [&SHADER]

        Arguments
        ---------
        - height (Float) : socket 'Height'
        - midlevel (Float) : socket 'Midlevel'
        - scale (Float) : socket 'Scale'
        - normal (Vector) : socket 'Normal'
        - space (str): parameter 'space' in ('OBJECT', 'WORLD')

        Returns
        -------
        - Vector
        """
        node = Node('Displacement', {'Height': height, 'Midlevel': midlevel, 'Scale': scale, 'Normal': normal}, space=space)
        return node._out


    @classmethod
    def specular_bsdf(cls, base_color=None, specular=None, roughness=None, emissive_color=None, transparency=None, normal=None, clear_coat=None, clear_coat_roughness=None, clear_coat_normal=None, weight=None):
        """ > Node <&ShaderNode Specular BSDF>

        [&SHADER]

        Arguments
        ---------
        - base_color (Color) : socket 'Base Color'
        - specular (Color) : socket 'Specular'
        - roughness (Float) : socket 'Roughness'
        - emissive_color (Color) : socket 'Emissive Color'
        - transparency (Float) : socket 'Transparency'
        - normal (Vector) : socket 'Normal'
        - clear_coat (Float) : socket 'Clear Coat'
        - clear_coat_roughness (Float) : socket 'Clear Coat Roughness'
        - clear_coat_normal (Vector) : socket 'Clear Coat Normal'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Specular BSDF', {'Base Color': base_color, 'Specular': specular, 'Roughness': roughness, 'Emissive Color': emissive_color, 'Transparency': transparency, 'Normal': normal, 'Clear Coat': clear_coat, 'Clear Coat Roughness': clear_coat_roughness, 'Clear Coat Normal': clear_coat_normal, 'Weight': weight})
        return node._out


    @classmethod
    def emission(cls, color=None, strength=None, weight=None):
        """ > Node <&ShaderNode Emission>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - strength (Float) : socket 'Strength'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Emission', {'Color': color, 'Strength': strength, 'Weight': weight})
        return node._out


    @classmethod
    def fresnel(cls, ior=None, normal=None):
        """ > Node <&ShaderNode Fresnel>

        [&SHADER]

        Arguments
        ---------
        - ior (Float) : socket 'IOR'
        - normal (Vector) : socket 'Normal'

        Returns
        -------
        - Float
        """
        node = Node('Fresnel', {'IOR': ior, 'Normal': normal})
        return node._out


    @classmethod
    def gamma(cls, color=None, gamma=None):
        """ > Node <&ShaderNode Gamma>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - gamma (Float) : socket 'Gamma'

        Returns
        -------
        - Color
        """
        node = Node('Gamma', {'Color': color, 'Gamma': gamma})
        return node._out


    @classmethod
    def group(cls, node_tree=None):
        """ > Node <&ShaderNode Group>

        [&SHADER]

        Arguments
        ---------
        - node_tree (NoneType): parameter 'node_tree'

        Returns
        -------
        - Node : 'Group'
        """
        node = Node('Group', node_tree=node_tree)
        return node


    @classmethod
    @property
    def curves_info(cls):
        """ > Node <&ShaderNode Curves Info>

        [&SHADER]

        Returns
        -------
        - Node : 'Curves Info'
        """
        node = Node('Curves Info')
        return node


    @classmethod
    def holdout(cls, weight=None):
        """ > Node <&ShaderNode Holdout>

        [&SHADER]

        Arguments
        ---------
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Holdout', {'Weight': weight})
        return node._out


    @classmethod
    def hue_saturation_value(cls, hue=None, saturation=None, value=None, fac=None, color=None):
        """ > Node <&ShaderNode Hue/Saturation/Value>

        [&SHADER]

        Arguments
        ---------
        - hue (Float) : socket 'Hue'
        - saturation (Float) : socket 'Saturation'
        - value (Float) : socket 'Value'
        - fac (Float) : socket 'Fac'
        - color (Color) : socket 'Color'

        Returns
        -------
        - Color
        """
        node = Node('Hue/Saturation/Value', {'Hue': hue, 'Saturation': saturation, 'Value': value, 'Fac': fac, 'Color': color})
        return node._out


    @classmethod
    def invert_color(cls, fac=None, color=None):
        """ > Node <&ShaderNode Invert Color>

        [&SHADER]

        Arguments
        ---------
        - fac (Float) : socket 'Fac'
        - color (Color) : socket 'Color'

        Returns
        -------
        - Color
        """
        node = Node('Invert Color', {'Fac': fac, 'Color': color})
        return node._out


    @classmethod
    def layer_weight(cls, blend=None, normal=None):
        """ > Node <&ShaderNode Layer Weight>

        [&SHADER]

        Arguments
        ---------
        - blend (Float) : socket 'Blend'
        - normal (Vector) : socket 'Normal'

        Returns
        -------
        - Node : 'Layer Weight'
        """
        node = Node('Layer Weight', {'Blend': blend, 'Normal': normal})
        return node


    @classmethod
    def light_falloff(cls, strength=None, smooth=None):
        """ > Node <&ShaderNode Light Falloff>

        [&SHADER]

        Arguments
        ---------
        - strength (Float) : socket 'Strength'
        - smooth (Float) : socket 'Smooth'

        Returns
        -------
        - Node : 'Light Falloff'
        """
        node = Node('Light Falloff', {'Strength': strength, 'Smooth': smooth})
        return node


    @classmethod
    @property
    def light_path(cls):
        """ > Node <&ShaderNode Light Path>

        [&SHADER]

        Returns
        -------
        - Node : 'Light Path'
        """
        node = Node('Light Path')
        return node


    @classmethod
    def mapping(cls, vector=None, location=None, rotation=None, scale=None, vector_type='POINT'):
        """ > Node <&ShaderNode Mapping>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - location (Vector) : socket 'Location'
        - rotation (Vector) : socket 'Rotation'
        - scale (Vector) : socket 'Scale'
        - vector_type (str): parameter 'vector_type' in ('POINT', 'TEXTURE', 'VECTOR', 'NORMAL')

        Returns
        -------
        - Vector
        """
        node = Node('Mapping', {'Vector': vector, 'Location': location, 'Rotation': rotation, 'Scale': scale}, vector_type=vector_type)
        return node._out


    @classmethod
    def mix_shader(cls, fac=None, shader=None, shader_1=None):
        """ > Node <&ShaderNode Mix Shader>

        [&SHADER]

        Arguments
        ---------
        - fac (Float) : socket 'Fac'
        - shader (Shader) : socket 'Shader'
        - shader_1 (Shader) : socket 'Shader' (id: 'Shader_001')

        Returns
        -------
        - Shader
        """
        node = Node('Mix Shader', {'Fac': fac, 'Shader': shader, 'Shader_001': shader_1})
        return node._out


    @classmethod
    @property
    def geometry(cls):
        """ > Node <&ShaderNode Geometry>

        [&SHADER]

        Returns
        -------
        - Node : 'Geometry'
        """
        node = Node('Geometry')
        return node


    @classmethod
    def normal(cls, normal=None):
        """ > Node <&ShaderNode Normal>

        [&SHADER]

        Arguments
        ---------
        - normal (Vector) : socket 'Normal'

        Returns
        -------
        - Node : 'Normal'
        """
        node = Node('Normal', {'Normal': normal})
        return node


    @classmethod
    def normal_map(cls, strength=None, color=None, space='TANGENT', uv_map=''):
        """ > Node <&ShaderNode Normal Map>

        [&SHADER]

        Arguments
        ---------
        - strength (Float) : socket 'Strength'
        - color (Color) : socket 'Color'
        - space (str): parameter 'space' in ('TANGENT', 'OBJECT', 'WORLD', 'BLENDER_OBJECT', 'BLENDER_WORLD')
        - uv_map (str): parameter 'uv_map'

        Returns
        -------
        - Vector
        """
        node = Node('Normal Map', {'Strength': strength, 'Color': color}, space=space, uv_map=uv_map)
        return node._out


    @classmethod
    @property
    def object_info(cls):
        """ > Node <&ShaderNode Object Info>

        [&SHADER]

        Returns
        -------
        - Node : 'Object Info'
        """
        node = Node('Object Info')
        return node


    @classmethod
    def aov_output(cls, color=None, value=None, aov_name=''):
        """ > Node <&ShaderNode AOV Output>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - value (Float) : socket 'Value'
        - aov_name (str): parameter 'aov_name'

        Returns
        -------
        - Node : 'AOV Output'
        """
        node = Node('AOV Output', {'Color': color, 'Value': value}, aov_name=aov_name)
        return node


    @classmethod
    def light_output(cls, surface=None, is_active_output=True, target='ALL'):
        """ > Node <&ShaderNode Light Output>

        [&SHADER]

        Arguments
        ---------
        - surface (Shader) : socket 'Surface'
        - is_active_output (bool): parameter 'is_active_output'
        - target (str): parameter 'target' in ('ALL', 'EEVEE', 'CYCLES')

        Returns
        -------
        - Node : 'Light Output'
        """
        node = Node('Light Output', {'Surface': surface}, is_active_output=is_active_output, target=target)
        return node


    @classmethod
    def line_style_output(cls, color=None, color_fac=None, alpha=None, alpha_fac=None, blend_type='MIX', is_active_output=True, target='ALL', use_alpha=False, use_clamp=False):
        """ > Node <&ShaderNode Line Style Output>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - color_fac (Float) : socket 'Color Fac'
        - alpha (Float) : socket 'Alpha'
        - alpha_fac (Float) : socket 'Alpha Fac'
        - blend_type (str): parameter 'blend_type' in ('MIX', 'DARKEN', 'MULTIPLY', 'BURN', 'LIGHTEN', 'SCREEN', 'DODGE', 'ADD', 'OVERLAY', 'SOFT_LIGHT', 'LINEAR_LIGHT', 'DIFFERENCE', 'EXCLUSION', 'SUBTRACT', 'DIVIDE', 'HUE', 'SATURATION', 'COLOR', 'VALUE')
        - is_active_output (bool): parameter 'is_active_output'
        - target (str): parameter 'target' in ('ALL', 'EEVEE', 'CYCLES')
        - use_alpha (bool): parameter 'use_alpha'
        - use_clamp (bool): parameter 'use_clamp'

        Returns
        -------
        - Node : 'Line Style Output'
        """
        node = Node('Line Style Output', {'Color': color, 'Color Fac': color_fac, 'Alpha': alpha, 'Alpha Fac': alpha_fac}, blend_type=blend_type, is_active_output=is_active_output, target=target, use_alpha=use_alpha, use_clamp=use_clamp)
        return node


    @classmethod
    def material_output(cls, surface=None, volume=None, displacement=None, thickness=None, is_active_output=True, target='ALL'):
        """ > Node <&ShaderNode Material Output>

        [&SHADER]

        Arguments
        ---------
        - surface (Shader) : socket 'Surface'
        - volume (Shader) : socket 'Volume'
        - displacement (Vector) : socket 'Displacement'
        - thickness (Float) : socket 'Thickness'
        - is_active_output (bool): parameter 'is_active_output'
        - target (str): parameter 'target' in ('ALL', 'EEVEE', 'CYCLES')

        Returns
        -------
        - Node : 'Material Output'
        """
        node = Node('Material Output', {'Surface': surface, 'Volume': volume, 'Displacement': displacement, 'Thickness': thickness}, is_active_output=is_active_output, target=target)
        return node


    @classmethod
    def world_output(cls, surface=None, volume=None, is_active_output=True, target='ALL'):
        """ > Node <&ShaderNode World Output>

        [&SHADER]

        Arguments
        ---------
        - surface (Shader) : socket 'Surface'
        - volume (Shader) : socket 'Volume'
        - is_active_output (bool): parameter 'is_active_output'
        - target (str): parameter 'target' in ('ALL', 'EEVEE', 'CYCLES')

        Returns
        -------
        - Node : 'World Output'
        """
        node = Node('World Output', {'Surface': surface, 'Volume': volume}, is_active_output=is_active_output, target=target)
        return node


    @classmethod
    @property
    def particle_info(cls):
        """ > Node <&ShaderNode Particle Info>

        [&SHADER]

        Returns
        -------
        - Node : 'Particle Info'
        """
        node = Node('Particle Info')
        return node


    @classmethod
    @property
    def point_info(cls):
        """ > Node <&ShaderNode Point Info>

        [&SHADER]

        Returns
        -------
        - Node : 'Point Info'
        """
        node = Node('Point Info')
        return node


    @classmethod
    @property
    def rgb(cls):
        """ > Node <&ShaderNode RGB>

        [&SHADER]

        Returns
        -------
        - Color
        """
        node = Node('RGB')
        return node._out


    @classmethod
    def rgb_to_bw(cls, color=None):
        """ > Node <&ShaderNode RGB to BW>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'

        Returns
        -------
        - Float
        """
        node = Node('RGB to BW', {'Color': color})
        return node._out


    @classmethod
    def script(cls, bytecode='', bytecode_hash='', filepath='', mode='INTERNAL', script=None, use_auto_update=False):
        """ > Node <&ShaderNode Script>

        [&SHADER]

        Arguments
        ---------
        - bytecode (str): parameter 'bytecode'
        - bytecode_hash (str): parameter 'bytecode_hash'
        - filepath (str): parameter 'filepath'
        - mode (str): parameter 'mode' in ('INTERNAL', 'EXTERNAL')
        - script (NoneType): parameter 'script'
        - use_auto_update (bool): parameter 'use_auto_update'

        Returns
        -------
        - Node : 'Script'
        """
        node = Node('Script', bytecode=bytecode, bytecode_hash=bytecode_hash, filepath=filepath, mode=mode, script=script, use_auto_update=use_auto_update)
        return node


    @classmethod
    def separate_color(cls, color=None, mode='RGB'):
        """ > Node <&ShaderNode Separate Color>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - mode (str): parameter 'mode' in ('RGB', 'HSV', 'HSL')

        Returns
        -------
        - Node : 'Separate Color'
        """
        node = Node('Separate Color', {'Color': color}, mode=mode)
        return node


    @classmethod
    def shader_to_rgb(cls, shader=None):
        """ > Node <&ShaderNode Shader to RGB>

        [&SHADER]

        Arguments
        ---------
        - shader (Shader) : socket 'Shader'

        Returns
        -------
        - Node : 'Shader to RGB'
        """
        node = Node('Shader to RGB', {'Shader': shader})
        return node


    @classmethod
    def subsurface_scattering(cls, color=None, scale=None, radius=None, ior=None, roughness=None, anisotropy=None, normal=None, weight=None, falloff='RANDOM_WALK'):
        """ > Node <&ShaderNode Subsurface Scattering>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - scale (Float) : socket 'Scale'
        - radius (Vector) : socket 'Radius'
        - ior (Float) : socket 'IOR'
        - roughness (Float) : socket 'Roughness'
        - anisotropy (Float) : socket 'Anisotropy'
        - normal (Vector) : socket 'Normal'
        - weight (Float) : socket 'Weight'
        - falloff (str): parameter 'falloff' in ('BURLEY', 'RANDOM_WALK', 'RANDOM_WALK_SKIN')

        Returns
        -------
        - Shader
        """
        node = Node('Subsurface Scattering', {'Color': color, 'Scale': scale, 'Radius': radius, 'IOR': ior, 'Roughness': roughness, 'Anisotropy': anisotropy, 'Normal': normal, 'Weight': weight}, falloff=falloff)
        return node._out


    @classmethod
    def tangent(cls, axis='Z', direction_type='RADIAL', uv_map=''):
        """ > Node <&ShaderNode Tangent>

        [&SHADER]

        Arguments
        ---------
        - axis (str): parameter 'axis' in ('X', 'Y', 'Z')
        - direction_type (str): parameter 'direction_type' in ('RADIAL', 'UV_MAP')
        - uv_map (str): parameter 'uv_map'

        Returns
        -------
        - Vector
        """
        node = Node('Tangent', axis=axis, direction_type=direction_type, uv_map=uv_map)
        return node._out


    @classmethod
    def texture_coordinate(cls, from_instancer=False, object=None):
        """ > Node <&ShaderNode Texture Coordinate>

        [&SHADER]

        Arguments
        ---------
        - from_instancer (bool): parameter 'from_instancer'
        - object (NoneType): parameter 'object'

        Returns
        -------
        - Node : 'Texture Coordinate'
        """
        node = Node('Texture Coordinate', from_instancer=from_instancer, object=get_object(object))
        return node


    @classmethod
    def environment_texture(cls, vector=None, color_mapping=None, image=None, image_user=None, interpolation='Linear', projection='EQUIRECTANGULAR', texture_mapping=None):
        """ > Node <&ShaderNode Environment Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - image (NoneType): parameter 'image'
        - image_user (ImageUser): parameter 'image_user'
        - interpolation (str): parameter 'interpolation' in ('Linear', 'Closest', 'Cubic', 'Smart')
        - projection (str): parameter 'projection' in ('EQUIRECTANGULAR', 'MIRROR_BALL')
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Color
        """
        node = Node('Environment Texture', {'Vector': vector}, color_mapping=color_mapping, image=image, image_user=image_user, interpolation=interpolation, projection=projection, texture_mapping=texture_mapping)
        return node._out


    @classmethod
    def ies_texture(cls, vector=None, strength=None, filepath='', ies=None, mode='INTERNAL'):
        """ > Node <&ShaderNode IES Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - strength (Float) : socket 'Strength'
        - filepath (str): parameter 'filepath'
        - ies (NoneType): parameter 'ies'
        - mode (str): parameter 'mode' in ('INTERNAL', 'EXTERNAL')

        Returns
        -------
        - Float
        """
        node = Node('IES Texture', {'Vector': vector, 'Strength': strength}, filepath=filepath, ies=ies, mode=mode)
        return node._out


    @classmethod
    def image_texture(cls, vector=None, color_mapping=None, extension='REPEAT', image=None, image_user=None, interpolation='Linear', projection='FLAT', projection_blend=0.0, texture_mapping=None):
        """ > Node <&ShaderNode Image Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - extension (str): parameter 'extension' in ('REPEAT', 'EXTEND', 'CLIP', 'MIRROR')
        - image (NoneType): parameter 'image'
        - image_user (ImageUser): parameter 'image_user'
        - interpolation (str): parameter 'interpolation' in ('Linear', 'Closest', 'Cubic', 'Smart')
        - projection (str): parameter 'projection' in ('FLAT', 'BOX', 'SPHERE', 'TUBE')
        - projection_blend (float): parameter 'projection_blend'
        - texture_mapping (TexMapping): parameter 'texture_mapping'

        Returns
        -------
        - Node : 'Image Texture'
        """
        node = Node('Image Texture', {'Vector': vector}, color_mapping=color_mapping, extension=extension, image=image, image_user=image_user, interpolation=interpolation, projection=projection, projection_blend=projection_blend, texture_mapping=texture_mapping)
        return node


    @classmethod
    def point_density(cls, vector=None, cache_point_density=None, calc_point_density=None, calc_point_density_minmax=None, interpolation='Linear', object=None, particle_color_source='PARTICLE_AGE', particle_system=None, point_source='PARTICLE_SYSTEM', radius=0.30000001192092896, resolution=100, space='OBJECT', vertex_attribute_name='', vertex_color_source='VERTEX_COLOR'):
        """ > Node <&ShaderNode Point Density>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - cache_point_density (bpy_func): parameter 'cache_point_density'
        - calc_point_density (bpy_func): parameter 'calc_point_density'
        - calc_point_density_minmax (bpy_func): parameter 'calc_point_density_minmax'
        - interpolation (str): parameter 'interpolation' in ('Closest', 'Linear', 'Cubic')
        - object (NoneType): parameter 'object'
        - particle_color_source (str): parameter 'particle_color_source' in ('PARTICLE_AGE', 'PARTICLE_SPEED', 'PARTICLE_VELOCITY')
        - particle_system (NoneType): parameter 'particle_system'
        - point_source (str): parameter 'point_source' in ('PARTICLE_SYSTEM', 'OBJECT')
        - radius (float): parameter 'radius'
        - resolution (int): parameter 'resolution'
        - space (str): parameter 'space' in ('OBJECT', 'WORLD')
        - vertex_attribute_name (str): parameter 'vertex_attribute_name'
        - vertex_color_source (str): parameter 'vertex_color_source' in ('VERTEX_COLOR', 'VERTEX_WEIGHT', 'VERTEX_NORMAL')

        Returns
        -------
        - Node : 'Point Density'
        """
        node = Node('Point Density', {'Vector': vector}, cache_point_density=cache_point_density, calc_point_density=calc_point_density, calc_point_density_minmax=calc_point_density_minmax, interpolation=interpolation, object=get_object(object), particle_color_source=particle_color_source, particle_system=particle_system, point_source=point_source, radius=radius, resolution=resolution, space=space, vertex_attribute_name=vertex_attribute_name, vertex_color_source=vertex_color_source)
        return node


    @classmethod
    def sky_texture(cls, vector=None, air_density=1.0, altitude=0.0, color_mapping=None, dust_density=1.0, ground_albedo=0.30000001192092896, ozone_density=1.0, sky_type='NISHITA', sun_direction=None, sun_disc=True, sun_elevation=0.2617993950843811, sun_intensity=1.0, sun_rotation=0.0, sun_size=0.009512044489383698, texture_mapping=None, turbidity=2.200000047683716):
        """ > Node <&ShaderNode Sky Texture>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - air_density (float): parameter 'air_density'
        - altitude (float): parameter 'altitude'
        - color_mapping (ColorMapping): parameter 'color_mapping'
        - dust_density (float): parameter 'dust_density'
        - ground_albedo (float): parameter 'ground_albedo'
        - ozone_density (float): parameter 'ozone_density'
        - sky_type (str): parameter 'sky_type' in ('PREETHAM', 'HOSEK_WILKIE', 'NISHITA')
        - sun_direction (Vector): parameter 'sun_direction'
        - sun_disc (bool): parameter 'sun_disc'
        - sun_elevation (float): parameter 'sun_elevation'
        - sun_intensity (float): parameter 'sun_intensity'
        - sun_rotation (float): parameter 'sun_rotation'
        - sun_size (float): parameter 'sun_size'
        - texture_mapping (TexMapping): parameter 'texture_mapping'
        - turbidity (float): parameter 'turbidity'

        Returns
        -------
        - Color
        """
        node = Node('Sky Texture', {'Vector': vector}, air_density=air_density, altitude=altitude, color_mapping=color_mapping, dust_density=dust_density, ground_albedo=ground_albedo, ozone_density=ozone_density, sky_type=sky_type, sun_direction=sun_direction, sun_disc=sun_disc, sun_elevation=sun_elevation, sun_intensity=sun_intensity, sun_rotation=sun_rotation, sun_size=sun_size, texture_mapping=texture_mapping, turbidity=turbidity)
        return node._out


    @classmethod
    def uv_along_stroke(cls, use_tips=False):
        """ > Node <&ShaderNode UV Along Stroke>

        [&SHADER]

        Arguments
        ---------
        - use_tips (bool): parameter 'use_tips'

        Returns
        -------
        - Vector
        """
        node = Node('UV Along Stroke', use_tips=use_tips)
        return node._out


    @classmethod
    def uv_map(cls, from_instancer=False, uv_map=''):
        """ > Node <&ShaderNode UV Map>

        [&SHADER]

        Arguments
        ---------
        - from_instancer (bool): parameter 'from_instancer'
        - uv_map (str): parameter 'uv_map'

        Returns
        -------
        - Vector
        """
        node = Node('UV Map', from_instancer=from_instancer, uv_map=uv_map)
        return node._out


    @classmethod
    def vector_displacement(cls, vector=None, midlevel=None, scale=None, space='TANGENT'):
        """ > Node <&ShaderNode Vector Displacement>

        [&SHADER]

        Arguments
        ---------
        - vector (Color) : socket 'Vector'
        - midlevel (Float) : socket 'Midlevel'
        - scale (Float) : socket 'Scale'
        - space (str): parameter 'space' in ('TANGENT', 'OBJECT', 'WORLD')

        Returns
        -------
        - Vector
        """
        node = Node('Vector Displacement', {'Vector': vector, 'Midlevel': midlevel, 'Scale': scale}, space=space)
        return node._out


    @classmethod
    def vector_transform(cls, vector=None, convert_from='WORLD', convert_to='OBJECT', vector_type='VECTOR'):
        """ > Node <&ShaderNode Vector Transform>

        [&SHADER]

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - convert_from (str): parameter 'convert_from' in ('WORLD', 'OBJECT', 'CAMERA')
        - convert_to (str): parameter 'convert_to' in ('WORLD', 'OBJECT', 'CAMERA')
        - vector_type (str): parameter 'vector_type' in ('POINT', 'VECTOR', 'NORMAL')

        Returns
        -------
        - Vector
        """
        node = Node('Vector Transform', {'Vector': vector}, convert_from=convert_from, convert_to=convert_to, vector_type=vector_type)
        return node._out


    @classmethod
    def color_attribute(cls, layer_name=''):
        """ > Node <&ShaderNode Color Attribute>

        [&SHADER]

        Arguments
        ---------
        - layer_name (str): parameter 'layer_name'

        Returns
        -------
        - Node : 'Color Attribute'
        """
        node = Node('Color Attribute', layer_name=layer_name)
        return node


    @classmethod
    def volume_absorption(cls, color=None, density=None, weight=None):
        """ > Node <&ShaderNode Volume Absorption>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - density (Float) : socket 'Density'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Volume Absorption', {'Color': color, 'Density': density, 'Weight': weight})
        return node._out


    @classmethod
    @property
    def volume_info(cls):
        """ > Node <&ShaderNode Volume Info>

        [&SHADER]

        Returns
        -------
        - Node : 'Volume Info'
        """
        node = Node('Volume Info')
        return node


    @classmethod
    def principled_volume(cls, color=None, color_attribute=None, density=None, density_attribute=None, anisotropy=None, absorption_color=None, emission_strength=None, emission_color=None, blackbody_intensity=None, blackbody_tint=None, temperature=None, temperature_attribute=None, weight=None):
        """ > Node <&ShaderNode Principled Volume>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - color_attribute (String) : socket 'Color Attribute'
        - density (Float) : socket 'Density'
        - density_attribute (String) : socket 'Density Attribute'
        - anisotropy (Float) : socket 'Anisotropy'
        - absorption_color (Color) : socket 'Absorption Color'
        - emission_strength (Float) : socket 'Emission Strength'
        - emission_color (Color) : socket 'Emission Color'
        - blackbody_intensity (Float) : socket 'Blackbody Intensity'
        - blackbody_tint (Color) : socket 'Blackbody Tint'
        - temperature (Float) : socket 'Temperature'
        - temperature_attribute (String) : socket 'Temperature Attribute'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Shader
        """
        node = Node('Principled Volume', {'Color': color, 'Color Attribute': color_attribute, 'Density': density, 'Density Attribute': density_attribute, 'Anisotropy': anisotropy, 'Absorption Color': absorption_color, 'Emission Strength': emission_strength, 'Emission Color': emission_color, 'Blackbody Intensity': blackbody_intensity, 'Blackbody Tint': blackbody_tint, 'Temperature': temperature, 'Temperature Attribute': temperature_attribute, 'Weight': weight})
        return node._out


    @classmethod
    def volume_scatter(cls, color=None, density=None, anisotropy=None, ior=None, backscatter=None, alpha=None, diameter=None, weight=None, phase='HENYEY_GREENSTEIN'):
        """ > Node <&ShaderNode Volume Scatter>

        [&SHADER]

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - density (Float) : socket 'Density'
        - anisotropy (Float) : socket 'Anisotropy'
        - ior (Float) : socket 'IOR'
        - backscatter (Float) : socket 'Backscatter'
        - alpha (Float) : socket 'Alpha'
        - diameter (Float) : socket 'Diameter'
        - weight (Float) : socket 'Weight'
        - phase (str): parameter 'phase' in ('HENYEY_GREENSTEIN', 'FOURNIER_FORAND', 'DRAINE', 'RAYLEIGH', 'MIE')

        Returns
        -------
        - Shader
        """
        node = Node('Volume Scatter', {'Color': color, 'Density': density, 'Anisotropy': anisotropy, 'IOR': ior, 'Backscatter': backscatter, 'Alpha': alpha, 'Diameter': diameter, 'Weight': weight}, phase=phase)
        return node._out


    @classmethod
    def wavelength(cls, wavelength=None):
        """ > Node <&ShaderNode Wavelength>

        [&SHADER]

        Arguments
        ---------
        - wavelength (Float) : socket 'Wavelength'

        Returns
        -------
        - Color
        """
        node = Node('Wavelength', {'Wavelength': wavelength})
        return node._out


    @classmethod
    def wireframe(cls, size=None, use_pixel_size=False):
        """ > Node <&ShaderNode Wireframe>

        [&SHADER]

        Arguments
        ---------
        - size (Float) : socket 'Size'
        - use_pixel_size (bool): parameter 'use_pixel_size'

        Returns
        -------
        - Float
        """
        node = Node('Wireframe', {'Size': size}, use_pixel_size=use_pixel_size)
        return node._out


    @classmethod
    def _receipt_shader(cls):
        from geonodes import GeoNodes, ShaderNodes, nd, snd
        with ShaderNodes('receipt_shader'):
            snd.frame()
            snd.group_input
            snd.group_output()
            snd.reroute()
            snd.blackbody()
            snd.clamp()
            snd.combine_xyz()
            snd.float_curve()
            snd.map_range()
            snd.math()
            snd.mix()
            snd.rgb_curves()
            snd.separate_xyz()
            snd.brick_texture()
            snd.checker_texture()
            snd.gabor_texture()
            snd.gradient_texture()
            snd.magic_texture()
            snd.noise_texture()
            snd.voronoi_texture()
            snd.wave_texture()
            snd.white_noise_texture()
            snd.color_ramp()
            snd.value
            snd.vector_curves()
            snd.vector_math()
            snd.vector_rotate()
            snd.add_shader()
            snd.ambient_occlusion()
            snd.attribute()
            snd.background()
            snd.bevel()
            snd.brightness_contrast()
            snd.glossy_bsdf()
            snd.diffuse_bsdf()
            snd.glass_bsdf()
            snd.hair_bsdf()
            snd.principled_hair_bsdf()
            snd.metallic_bsdf()
            snd.principled_bsdf()
            snd.ray_portal_bsdf()
            snd.refraction_bsdf()
            snd.sheen_bsdf()
            snd.toon_bsdf()
            snd.translucent_bsdf()
            snd.transparent_bsdf()
            snd.bump()
            snd.camera_data
            snd.combine_color()
            snd.displacement()
            snd.specular_bsdf()
            snd.emission()
            snd.fresnel()
            snd.gamma()
            snd.group()
            snd.curves_info
            snd.holdout()
            snd.hue_saturation_value()
            snd.invert_color()
            snd.layer_weight()
            snd.light_falloff()
            snd.light_path
            snd.mapping()
            snd.mix_shader()
            snd.geometry
            snd.normal()
            snd.normal_map()
            snd.object_info
            snd.aov_output()
            snd.light_output()
            snd.line_style_output()
            snd.material_output()
            snd.world_output()
            snd.particle_info
            snd.point_info
            snd.rgb
            snd.rgb_to_bw()
            snd.script()
            snd.separate_color()
            snd.shader_to_rgb()
            snd.subsurface_scattering()
            snd.tangent()
            snd.texture_coordinate()
            snd.environment_texture()
            snd.ies_texture()
            snd.image_texture()
            snd.point_density()
            snd.sky_texture()
            snd.uv_along_stroke()
            snd.uv_map()
            snd.vector_displacement()
            snd.vector_transform()
            snd.color_attribute()
            snd.volume_absorption()
            snd.volume_info
            snd.principled_volume()
            snd.volume_scatter()
            snd.wavelength()
            snd.wireframe()

class nd(CommonStatic):
    @classmethod
    def align_rotation_to_vector(cls, rotation=None, factor=None, vector=None, axis='Z', pivot_axis='AUTO'):
        """ > Node <&Node Align Rotation to Vector>

        Arguments
        ---------
        - rotation (Rotation) : socket 'Rotation'
        - factor (Float) : socket 'Factor'
        - vector (Vector) : socket 'Vector'
        - axis (str): parameter 'axis' in ('X', 'Y', 'Z')
        - pivot_axis (str): parameter 'pivot_axis' in ('AUTO', 'X', 'Y', 'Z')

        Returns
        -------
        - Rotation
        """
        node = Node('Align Rotation to Vector', {'Rotation': rotation, 'Factor': factor, 'Vector': vector}, axis=axis, pivot_axis=pivot_axis)
        return node._out


    @classmethod
    def axes_to_rotation(cls, primary_axis_1=None, secondary_axis_1=None, primary_axis='Z', secondary_axis='X'):
        """ > Node <&Node Axes to Rotation>

        Arguments
        ---------
        - primary_axis_1 (Vector) : socket 'Primary Axis'
        - secondary_axis_1 (Vector) : socket 'Secondary Axis'
        - primary_axis (str): parameter 'primary_axis' in ('X', 'Y', 'Z')
        - secondary_axis (str): parameter 'secondary_axis' in ('X', 'Y', 'Z')

        Returns
        -------
        - Rotation
        """
        node = Node('Axes to Rotation', {'Primary Axis': primary_axis_1, 'Secondary Axis': secondary_axis_1}, primary_axis=primary_axis, secondary_axis=secondary_axis)
        return node._out


    @classmethod
    def axis_angle_to_rotation(cls, axis=None, angle=None):
        """ > Node <&Node Axis Angle to Rotation>

        Arguments
        ---------
        - axis (Vector) : socket 'Axis'
        - angle (Float) : socket 'Angle'

        Returns
        -------
        - Rotation
        """
        node = Node('Axis Angle to Rotation', {'Axis': axis, 'Angle': angle})
        return node._out


    @classmethod
    def boolean_math(cls, boolean=None, boolean_1=None, operation='AND'):
        """ > Node <&Node Boolean Math>

        Arguments
        ---------
        - boolean (Boolean) : socket 'Boolean'
        - boolean_1 (Boolean) : socket 'Boolean' (id: 'Boolean_001')
        - operation (str): parameter 'operation' in ('AND', 'OR', 'NOT', 'NAND', 'NOR', 'XNOR', 'XOR', 'IMPLY', 'NIMPLY')

        Returns
        -------
        - Boolean
        """
        node = Node('Boolean Math', {'Boolean': boolean, 'Boolean_001': boolean_1}, operation=operation)
        return node._out


    @classmethod
    def combine_color(cls, red=None, green=None, blue=None, alpha=None, mode='RGB'):
        """ > Node <&Node Combine Color>

        Arguments
        ---------
        - red (Float) : socket 'Red'
        - green (Float) : socket 'Green'
        - blue (Float) : socket 'Blue'
        - alpha (Float) : socket 'Alpha'
        - mode (str): parameter 'mode' in ('RGB', 'HSV', 'HSL')

        Returns
        -------
        - Color
        """
        node = Node('Combine Color', {'Red': red, 'Green': green, 'Blue': blue, 'Alpha': alpha}, mode=mode)
        return node._out


    @classmethod
    def combine_matrix(cls, column_1_row_1=None, column_1_row_2=None, column_1_row_3=None, column_1_row_4=None, column_2_row_1=None, column_2_row_2=None, column_2_row_3=None, column_2_row_4=None, column_3_row_1=None, column_3_row_2=None, column_3_row_3=None, column_3_row_4=None, column_4_row_1=None, column_4_row_2=None, column_4_row_3=None, column_4_row_4=None):
        """ > Node <&Node Combine Matrix>

        Arguments
        ---------
        - column_1_row_1 (Float) : socket 'Column 1 Row 1'
        - column_1_row_2 (Float) : socket 'Column 1 Row 2'
        - column_1_row_3 (Float) : socket 'Column 1 Row 3'
        - column_1_row_4 (Float) : socket 'Column 1 Row 4'
        - column_2_row_1 (Float) : socket 'Column 2 Row 1'
        - column_2_row_2 (Float) : socket 'Column 2 Row 2'
        - column_2_row_3 (Float) : socket 'Column 2 Row 3'
        - column_2_row_4 (Float) : socket 'Column 2 Row 4'
        - column_3_row_1 (Float) : socket 'Column 3 Row 1'
        - column_3_row_2 (Float) : socket 'Column 3 Row 2'
        - column_3_row_3 (Float) : socket 'Column 3 Row 3'
        - column_3_row_4 (Float) : socket 'Column 3 Row 4'
        - column_4_row_1 (Float) : socket 'Column 4 Row 1'
        - column_4_row_2 (Float) : socket 'Column 4 Row 2'
        - column_4_row_3 (Float) : socket 'Column 4 Row 3'
        - column_4_row_4 (Float) : socket 'Column 4 Row 4'

        Returns
        -------
        - Matrix
        """
        node = Node('Combine Matrix', {'Column 1 Row 1': column_1_row_1, 'Column 1 Row 2': column_1_row_2, 'Column 1 Row 3': column_1_row_3, 'Column 1 Row 4': column_1_row_4, 'Column 2 Row 1': column_2_row_1, 'Column 2 Row 2': column_2_row_2, 'Column 2 Row 3': column_2_row_3, 'Column 2 Row 4': column_2_row_4, 'Column 3 Row 1': column_3_row_1, 'Column 3 Row 2': column_3_row_2, 'Column 3 Row 3': column_3_row_3, 'Column 3 Row 4': column_3_row_4, 'Column 4 Row 1': column_4_row_1, 'Column 4 Row 2': column_4_row_2, 'Column 4 Row 3': column_4_row_3, 'Column 4 Row 4': column_4_row_4})
        return node._out


    @classmethod
    def combine_transform(cls, translation=None, rotation=None, scale=None):
        """ > Node <&Node Combine Transform>

        Arguments
        ---------
        - translation (Vector) : socket 'Translation'
        - rotation (Rotation) : socket 'Rotation'
        - scale (Vector) : socket 'Scale'

        Returns
        -------
        - Matrix
        """
        node = Node('Combine Transform', {'Translation': translation, 'Rotation': rotation, 'Scale': scale})
        return node._out


    @classmethod
    def compare(cls, a=None, b=None, c=None, angle=None, epsilon=None, data_type='FLOAT', mode='ELEMENT', operation='GREATER_THAN'):
        """ > Node <&Node Compare>

        Arguments
        ---------
        - a (Float) : socket 'A'
        - b (Float) : socket 'B'
        - c (Float) : socket 'C'
        - angle (Float) : socket 'Angle'
        - epsilon (Float) : socket 'Epsilon'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'VECTOR', 'STRING', 'RGBA')
        - mode (str): parameter 'mode' in ('ELEMENT', 'LENGTH', 'AVERAGE', 'DOT_PRODUCT', 'DIRECTION')
        - operation (str): parameter 'operation' in ('LESS_THAN', 'LESS_EQUAL', 'GREATER_THAN', 'GREATER_EQUAL', 'EQUAL', 'NOT_EQUAL')

        Returns
        -------
        - Boolean
        """
        node = Node('Compare', {'A': a, 'B': b, 'C': c, 'Angle': angle, 'Epsilon': epsilon}, data_type=data_type, mode=mode, operation=operation)
        return node._out


    @classmethod
    def euler_to_rotation(cls, euler=None):
        """ > Node <&Node Euler to Rotation>

        Arguments
        ---------
        - euler (Vector) : socket 'Euler'

        Returns
        -------
        - Rotation
        """
        node = Node('Euler to Rotation', {'Euler': euler})
        return node._out


    @classmethod
    def float_to_integer(cls, float=None, rounding_mode='ROUND'):
        """ > Node <&Node Float to Integer>

        Arguments
        ---------
        - float (Float) : socket 'Float'
        - rounding_mode (str): parameter 'rounding_mode' in ('ROUND', 'FLOOR', 'CEILING', 'TRUNCATE')

        Returns
        -------
        - Integer
        """
        node = Node('Float to Integer', {'Float': float}, rounding_mode=rounding_mode)
        return node._out


    @classmethod
    def hash_value(cls, value=None, seed=None, data_type='INT'):
        """ > Node <&Node Hash Value>

        Arguments
        ---------
        - value (Integer) : socket 'Value'
        - seed (Integer) : socket 'Seed'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'VECTOR', 'ROTATION', 'MATRIX', 'STRING', 'RGBA')

        Returns
        -------
        - Integer
        """
        node = Node('Hash Value', {'Value': value, 'Seed': seed}, data_type=data_type)
        return node._out


    @classmethod
    def boolean(cls, boolean=False):
        """ > Node <&Node Boolean>

        Arguments
        ---------
        - boolean (bool): parameter 'boolean'

        Returns
        -------
        - Boolean
        """
        node = Node('Boolean', boolean=boolean)
        return node._out


    @classmethod
    def color(cls, value=None):
        """ > Node <&Node Color>

        Arguments
        ---------
        - value (bpy_prop_array): parameter 'value'

        Returns
        -------
        - Color
        """
        node = Node('Color', value=value)
        return node._out


    @classmethod
    def integer(cls, integer=0):
        """ > Node <&Node Integer>

        Arguments
        ---------
        - integer (int): parameter 'integer'

        Returns
        -------
        - Integer
        """
        node = Node('Integer', integer=integer)
        return node._out


    @classmethod
    def rotation(cls, rotation_euler=None):
        """ > Node <&Node Rotation>

        Arguments
        ---------
        - rotation_euler (Euler): parameter 'rotation_euler'

        Returns
        -------
        - Rotation
        """
        node = Node('Rotation', rotation_euler=rotation_euler)
        return node._out


    @classmethod
    @property
    def special_characters(cls):
        """ > Node <&Node Special Characters>

        Returns
        -------
        - Node : 'Special Characters'
        """
        node = Node('Special Characters')
        return node


    @classmethod
    def string(cls, string=''):
        """ > Node <&Node String>

        Arguments
        ---------
        - string (str): parameter 'string'

        Returns
        -------
        - String
        """
        node = Node('String', string=string)
        return node._out


    @classmethod
    def vector(cls, vector=None):
        """ > Node <&Node Vector>

        Arguments
        ---------
        - vector (Vector): parameter 'vector'

        Returns
        -------
        - Vector
        """
        node = Node('Vector', vector=vector)
        return node._out


    @classmethod
    def integer_math(cls, value=None, value_1=None, value_2=None, operation='ADD'):
        """ > Node <&Node Integer Math>

        Arguments
        ---------
        - value (Integer) : socket 'Value'
        - value_1 (Integer) : socket 'Value' (id: 'Value_001')
        - value_2 (Integer) : socket 'Value' (id: 'Value_002')
        - operation (str): parameter 'operation' in ('ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE', 'MULTIPLY_ADD', 'ABSOLUTE', 'NEGATE', 'POWER', 'MINIMUM', 'MAXIMUM', 'SIGN', 'DIVIDE_ROUND', 'DIVIDE_FLOOR', 'DIVIDE_CEIL', 'FLOORED_MODULO', 'MODULO', 'GCD', 'LCM')

        Returns
        -------
        - Integer
        """
        node = Node('Integer Math', {'Value': value, 'Value_001': value_1, 'Value_002': value_2}, operation=operation)
        return node._out


    @classmethod
    def invert_matrix(cls, matrix=None):
        """ > Node <&Node Invert Matrix>

        Arguments
        ---------
        - matrix (Matrix) : socket 'Matrix'

        Returns
        -------
        - Node : 'Invert Matrix'
        """
        node = Node('Invert Matrix', {'Matrix': matrix})
        return node


    @classmethod
    def invert_rotation(cls, rotation=None):
        """ > Node <&Node Invert Rotation>

        Arguments
        ---------
        - rotation (Rotation) : socket 'Rotation'

        Returns
        -------
        - Rotation
        """
        node = Node('Invert Rotation', {'Rotation': rotation})
        return node._out


    @classmethod
    def matrix_determinant(cls, matrix=None):
        """ > Node <&Node Matrix Determinant>

        Arguments
        ---------
        - matrix (Matrix) : socket 'Matrix'

        Returns
        -------
        - Float
        """
        node = Node('Matrix Determinant', {'Matrix': matrix})
        return node._out


    @classmethod
    def multiply_matrices(cls, matrix=None, matrix_1=None):
        """ > Node <&Node Multiply Matrices>

        Arguments
        ---------
        - matrix (Matrix) : socket 'Matrix'
        - matrix_1 (Matrix) : socket 'Matrix' (id: 'Matrix_001')

        Returns
        -------
        - Matrix
        """
        node = Node('Multiply Matrices', {'Matrix': matrix, 'Matrix_001': matrix_1})
        return node._out


    @classmethod
    def project_point(cls, vector=None, transform=None):
        """ > Node <&Node Project Point>

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - transform (Matrix) : socket 'Transform'

        Returns
        -------
        - Vector
        """
        node = Node('Project Point', {'Vector': vector, 'Transform': transform})
        return node._out


    @classmethod
    def quaternion_to_rotation(cls, w=None, x=None, y=None, z=None):
        """ > Node <&Node Quaternion to Rotation>

        Arguments
        ---------
        - w (Float) : socket 'W'
        - x (Float) : socket 'X'
        - y (Float) : socket 'Y'
        - z (Float) : socket 'Z'

        Returns
        -------
        - Rotation
        """
        node = Node('Quaternion to Rotation', {'W': w, 'X': x, 'Y': y, 'Z': z})
        return node._out


    @classmethod
    def random_value(cls, min=None, max=None, probability=None, id=None, seed=None, data_type='FLOAT'):
        """ > Node <&Node Random Value>

        Arguments
        ---------
        - min (Float) : socket 'Min'
        - max (Float) : socket 'Max'
        - probability (Float) : socket 'Probability'
        - id (Integer) : socket 'ID'
        - seed (Integer) : socket 'Seed'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'BOOLEAN')

        Returns
        -------
        - Node : 'Random Value'
        """
        node = Node('Random Value', {'Min': min, 'Max': max, 'Probability': probability, 'ID': id, 'Seed': seed}, data_type=data_type)
        return node


    @classmethod
    def replace_string(cls, string=None, find=None, replace=None):
        """ > Node <&Node Replace String>

        Arguments
        ---------
        - string (String) : socket 'String'
        - find (String) : socket 'Find'
        - replace (String) : socket 'Replace'

        Returns
        -------
        - String
        """
        node = Node('Replace String', {'String': string, 'Find': find, 'Replace': replace})
        return node._out


    @classmethod
    def rotate_rotation(cls, rotation=None, rotate_by=None, rotation_space='GLOBAL'):
        """ > Node <&Node Rotate Rotation>

        Arguments
        ---------
        - rotation (Rotation) : socket 'Rotation'
        - rotate_by (Rotation) : socket 'Rotate By'
        - rotation_space (str): parameter 'rotation_space' in ('GLOBAL', 'LOCAL')

        Returns
        -------
        - Rotation
        """
        node = Node('Rotate Rotation', {'Rotation': rotation, 'Rotate By': rotate_by}, rotation_space=rotation_space)
        return node._out


    @classmethod
    def rotate_vector(cls, vector=None, rotation=None):
        """ > Node <&Node Rotate Vector>

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - rotation (Rotation) : socket 'Rotation'

        Returns
        -------
        - Vector
        """
        node = Node('Rotate Vector', {'Vector': vector, 'Rotation': rotation})
        return node._out


    @classmethod
    def rotation_to_axis_angle(cls, rotation=None):
        """ > Node <&Node Rotation to Axis Angle>

        Arguments
        ---------
        - rotation (Rotation) : socket 'Rotation'

        Returns
        -------
        - Node : 'Rotation to Axis Angle'
        """
        node = Node('Rotation to Axis Angle', {'Rotation': rotation})
        return node


    @classmethod
    def rotation_to_euler(cls, rotation=None):
        """ > Node <&Node Rotation to Euler>

        Arguments
        ---------
        - rotation (Rotation) : socket 'Rotation'

        Returns
        -------
        - Vector
        """
        node = Node('Rotation to Euler', {'Rotation': rotation})
        return node._out


    @classmethod
    def rotation_to_quaternion(cls, rotation=None):
        """ > Node <&Node Rotation to Quaternion>

        Arguments
        ---------
        - rotation (Rotation) : socket 'Rotation'

        Returns
        -------
        - Node : 'Rotation to Quaternion'
        """
        node = Node('Rotation to Quaternion', {'Rotation': rotation})
        return node


    @classmethod
    def separate_color(cls, color=None, mode='RGB'):
        """ > Node <&Node Separate Color>

        Arguments
        ---------
        - color (Color) : socket 'Color'
        - mode (str): parameter 'mode' in ('RGB', 'HSV', 'HSL')

        Returns
        -------
        - Node : 'Separate Color'
        """
        node = Node('Separate Color', {'Color': color}, mode=mode)
        return node


    @classmethod
    def separate_matrix(cls, matrix=None):
        """ > Node <&Node Separate Matrix>

        Arguments
        ---------
        - matrix (Matrix) : socket 'Matrix'

        Returns
        -------
        - Node : 'Separate Matrix'
        """
        node = Node('Separate Matrix', {'Matrix': matrix})
        return node


    @classmethod
    def separate_transform(cls, transform=None):
        """ > Node <&Node Separate Transform>

        Arguments
        ---------
        - transform (Matrix) : socket 'Transform'

        Returns
        -------
        - Node : 'Separate Transform'
        """
        node = Node('Separate Transform', {'Transform': transform})
        return node


    @classmethod
    def slice_string(cls, string=None, position=None, length=None):
        """ > Node <&Node Slice String>

        Arguments
        ---------
        - string (String) : socket 'String'
        - position (Integer) : socket 'Position'
        - length (Integer) : socket 'Length'

        Returns
        -------
        - String
        """
        node = Node('Slice String', {'String': string, 'Position': position, 'Length': length})
        return node._out


    @classmethod
    def string_length(cls, string=None):
        """ > Node <&Node String Length>

        Arguments
        ---------
        - string (String) : socket 'String'

        Returns
        -------
        - Integer
        """
        node = Node('String Length', {'String': string})
        return node._out


    @classmethod
    def transform_direction(cls, direction=None, transform=None):
        """ > Node <&Node Transform Direction>

        Arguments
        ---------
        - direction (Vector) : socket 'Direction'
        - transform (Matrix) : socket 'Transform'

        Returns
        -------
        - Vector
        """
        node = Node('Transform Direction', {'Direction': direction, 'Transform': transform})
        return node._out


    @classmethod
    def transform_point(cls, vector=None, transform=None):
        """ > Node <&Node Transform Point>

        Arguments
        ---------
        - vector (Vector) : socket 'Vector'
        - transform (Matrix) : socket 'Transform'

        Returns
        -------
        - Vector
        """
        node = Node('Transform Point', {'Vector': vector, 'Transform': transform})
        return node._out


    @classmethod
    def transpose_matrix(cls, matrix=None):
        """ > Node <&Node Transpose Matrix>

        Arguments
        ---------
        - matrix (Matrix) : socket 'Matrix'

        Returns
        -------
        - Matrix
        """
        node = Node('Transpose Matrix', {'Matrix': matrix})
        return node._out


    @classmethod
    def value_to_string(cls, value=None, decimals=None, data_type='FLOAT'):
        """ > Node <&Node Value to String>

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - decimals (Integer) : socket 'Decimals'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT')

        Returns
        -------
        - String
        """
        node = Node('Value to String', {'Value': value, 'Decimals': decimals}, data_type=data_type)
        return node._out


    @classmethod
    def accumulate_field(cls, value=None, group_id=None, data_type='FLOAT', domain='POINT'):
        """ > Node <&Node Accumulate Field>

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - group_id (Integer) : socket 'Group ID'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'TRANSFORM')
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Node : 'Accumulate Field'
        """
        node = Node('Accumulate Field', {'Value': value, 'Group ID': group_id}, data_type=data_type, domain=domain)
        return node


    @classmethod
    def domain_size(cls, geometry=None, component='MESH'):
        """ > Node <&Node Domain Size>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - component (str): parameter 'component' in ('MESH', 'POINTCLOUD', 'CURVE', 'INSTANCES', 'GREASEPENCIL')

        Returns
        -------
        - Node : 'Domain Size'
        """
        node = Node('Domain Size', {'Geometry': geometry}, component=component)
        return node


    @classmethod
    def attribute_statistic(cls, geometry=None, selection=None, attribute=None, data_type='FLOAT', domain='POINT'):
        """ > Node <&Node Attribute Statistic>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - attribute (Float) : socket 'Attribute'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'FLOAT_VECTOR')
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Node : 'Attribute Statistic'
        """
        node = Node('Attribute Statistic', {'Geometry': geometry, 'Selection': selection, 'Attribute': attribute}, data_type=data_type, domain=domain)
        return node


    @classmethod
    def bake(cls, _items={}, geometry=None):
        """ > Node <&Node Bake>

        Arguments
        ---------
        - items (dict) : items to create
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Node : 'Bake'
        """
        node = Node('Bake', {'Geometry': geometry}, _items=_items)
        return node


    @classmethod
    def blur_attribute(cls, value=None, iterations=None, weight=None, data_type='FLOAT'):
        """ > Node <&Node Blur Attribute>

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - iterations (Integer) : socket 'Iterations'
        - weight (Float) : socket 'Weight'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR')

        Returns
        -------
        - Float
        """
        node = Node('Blur Attribute', {'Value': value, 'Iterations': iterations, 'Weight': weight}, data_type=data_type)
        return node._out


    @classmethod
    def bounding_box(cls, geometry=None):
        """ > Node <&Node Bounding Box>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Node : 'Bounding Box'
        """
        node = Node('Bounding Box', {'Geometry': geometry})
        return node


    @classmethod
    def capture_attribute(cls, _items={}, geometry=None, domain='POINT'):
        """ > Node <&Node Capture Attribute>

        Arguments
        ---------
        - items (dict) : items to create
        - geometry (Geometry) : socket 'Geometry'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Node : 'Capture Attribute'
        """
        node = Node('Capture Attribute', {'Geometry': geometry}, _items=_items, domain=domain)
        return node


    @classmethod
    def collection_info(cls, collection=None, separate_children=None, reset_children=None, transform_space='ORIGINAL'):
        """ > Node <&Node Collection Info>

        Arguments
        ---------
        - collection (Collection) : socket 'Collection'
        - separate_children (Boolean) : socket 'Separate Children'
        - reset_children (Boolean) : socket 'Reset Children'
        - transform_space (str): parameter 'transform_space' in ('ORIGINAL', 'RELATIVE')

        Returns
        -------
        - Geometry
        """
        node = Node('Collection Info', {'Collection': collection, 'Separate Children': separate_children, 'Reset Children': reset_children}, transform_space=transform_space)
        return node._out


    @classmethod
    def convex_hull(cls, geometry=None):
        """ > Node <&Node Convex Hull>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Geometry
        """
        node = Node('Convex Hull', {'Geometry': geometry})
        return node._out


    @classmethod
    def corners_of_edge(cls, edge_index=None, weights=None, sort_index=None):
        """ > Node <&Node Corners of Edge>

        Arguments
        ---------
        - edge_index (Integer) : socket 'Edge Index'
        - weights (Float) : socket 'Weights'
        - sort_index (Integer) : socket 'Sort Index'

        Returns
        -------
        - Node : 'Corners of Edge'
        """
        node = Node('Corners of Edge', {'Edge Index': edge_index, 'Weights': weights, 'Sort Index': sort_index})
        return node


    @classmethod
    def corners_of_face(cls, face_index=None, weights=None, sort_index=None):
        """ > Node <&Node Corners of Face>

        Arguments
        ---------
        - face_index (Integer) : socket 'Face Index'
        - weights (Float) : socket 'Weights'
        - sort_index (Integer) : socket 'Sort Index'

        Returns
        -------
        - Node : 'Corners of Face'
        """
        node = Node('Corners of Face', {'Face Index': face_index, 'Weights': weights, 'Sort Index': sort_index})
        return node


    @classmethod
    def corners_of_vertex(cls, vertex_index=None, weights=None, sort_index=None):
        """ > Node <&Node Corners of Vertex>

        Arguments
        ---------
        - vertex_index (Integer) : socket 'Vertex Index'
        - weights (Float) : socket 'Weights'
        - sort_index (Integer) : socket 'Sort Index'

        Returns
        -------
        - Node : 'Corners of Vertex'
        """
        node = Node('Corners of Vertex', {'Vertex Index': vertex_index, 'Weights': weights, 'Sort Index': sort_index})
        return node


    @classmethod
    def arc(cls, resolution=None, start=None, middle=None, end=None, radius=None, start_angle=None, sweep_angle=None, offset_angle=None, connect_center=None, invert_arc=None, mode='RADIUS'):
        """ > Node <&Node Arc>

        Arguments
        ---------
        - resolution (Integer) : socket 'Resolution'
        - start (Vector) : socket 'Start'
        - middle (Vector) : socket 'Middle'
        - end (Vector) : socket 'End'
        - radius (Float) : socket 'Radius'
        - start_angle (Float) : socket 'Start Angle'
        - sweep_angle (Float) : socket 'Sweep Angle'
        - offset_angle (Float) : socket 'Offset Angle'
        - connect_center (Boolean) : socket 'Connect Center'
        - invert_arc (Boolean) : socket 'Invert Arc'
        - mode (str): parameter 'mode' in ('POINTS', 'RADIUS')

        Returns
        -------
        - Node : 'Arc'
        """
        node = Node('Arc', {'Resolution': resolution, 'Start': start, 'Middle': middle, 'End': end, 'Radius': radius, 'Start Angle': start_angle, 'Sweep Angle': sweep_angle, 'Offset Angle': offset_angle, 'Connect Center': connect_center, 'Invert Arc': invert_arc}, mode=mode)
        return node


    @classmethod
    def endpoint_selection(cls, start_size=None, end_size=None):
        """ > Node <&Node Endpoint Selection>

        Arguments
        ---------
        - start_size (Integer) : socket 'Start Size'
        - end_size (Integer) : socket 'End Size'

        Returns
        -------
        - Boolean
        """
        node = Node('Endpoint Selection', {'Start Size': start_size, 'End Size': end_size})
        return node._out


    @classmethod
    def handle_type_selection(cls, handle_type='AUTO', mode={'LEFT', 'RIGHT'}):
        """ > Node <&Node Handle Type Selection>

        Arguments
        ---------
        - handle_type (str): parameter 'handle_type' in ('FREE', 'AUTO', 'VECTOR', 'ALIGN')
        - mode (set): parameter 'mode'

        Returns
        -------
        - Boolean
        """
        node = Node('Handle Type Selection', handle_type=handle_type, mode=mode)
        return node._out


    @classmethod
    def curve_length(cls, curve=None):
        """ > Node <&Node Curve Length>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'

        Returns
        -------
        - Float
        """
        node = Node('Curve Length', {'Curve': curve})
        return node._out


    @classmethod
    def curve_of_point(cls, point_index=None):
        """ > Node <&Node Curve of Point>

        Arguments
        ---------
        - point_index (Integer) : socket 'Point Index'

        Returns
        -------
        - Node : 'Curve of Point'
        """
        node = Node('Curve of Point', {'Point Index': point_index})
        return node


    @classmethod
    def bezier_segment(cls, resolution=None, start=None, start_handle=None, end_handle=None, end=None, mode='POSITION'):
        """ > Node <&Node Bzier Segment>

        Arguments
        ---------
        - resolution (Integer) : socket 'Resolution'
        - start (Vector) : socket 'Start'
        - start_handle (Vector) : socket 'Start Handle'
        - end_handle (Vector) : socket 'End Handle'
        - end (Vector) : socket 'End'
        - mode (str): parameter 'mode' in ('POSITION', 'OFFSET')

        Returns
        -------
        - Geometry
        """
        node = Node('Bzier Segment', {'Resolution': resolution, 'Start': start, 'Start Handle': start_handle, 'End Handle': end_handle, 'End': end}, mode=mode)
        return node._out


    @classmethod
    def curve_circle(cls, resolution=None, point_1=None, point_2=None, point_3=None, radius=None, mode='RADIUS'):
        """ > Node <&Node Curve Circle>

        Arguments
        ---------
        - resolution (Integer) : socket 'Resolution'
        - point_1 (Vector) : socket 'Point 1'
        - point_2 (Vector) : socket 'Point 2'
        - point_3 (Vector) : socket 'Point 3'
        - radius (Float) : socket 'Radius'
        - mode (str): parameter 'mode' in ('POINTS', 'RADIUS')

        Returns
        -------
        - Node : 'Curve Circle'
        """
        node = Node('Curve Circle', {'Resolution': resolution, 'Point 1': point_1, 'Point 2': point_2, 'Point 3': point_3, 'Radius': radius}, mode=mode)
        return node


    @classmethod
    def curve_line(cls, start=None, end=None, direction=None, length=None, mode='POINTS'):
        """ > Node <&Node Curve Line>

        Arguments
        ---------
        - start (Vector) : socket 'Start'
        - end (Vector) : socket 'End'
        - direction (Vector) : socket 'Direction'
        - length (Float) : socket 'Length'
        - mode (str): parameter 'mode' in ('POINTS', 'DIRECTION')

        Returns
        -------
        - Geometry
        """
        node = Node('Curve Line', {'Start': start, 'End': end, 'Direction': direction, 'Length': length}, mode=mode)
        return node._out


    @classmethod
    def quadrilateral(cls, width=None, height=None, bottom_width=None, top_width=None, offset=None, bottom_height=None, top_height=None, point_1=None, point_2=None, point_3=None, point_4=None, mode='RECTANGLE'):
        """ > Node <&Node Quadrilateral>

        Arguments
        ---------
        - width (Float) : socket 'Width'
        - height (Float) : socket 'Height'
        - bottom_width (Float) : socket 'Bottom Width'
        - top_width (Float) : socket 'Top Width'
        - offset (Float) : socket 'Offset'
        - bottom_height (Float) : socket 'Bottom Height'
        - top_height (Float) : socket 'Top Height'
        - point_1 (Vector) : socket 'Point 1'
        - point_2 (Vector) : socket 'Point 2'
        - point_3 (Vector) : socket 'Point 3'
        - point_4 (Vector) : socket 'Point 4'
        - mode (str): parameter 'mode' in ('RECTANGLE', 'PARALLELOGRAM', 'TRAPEZOID', 'KITE', 'POINTS')

        Returns
        -------
        - Geometry
        """
        node = Node('Quadrilateral', {'Width': width, 'Height': height, 'Bottom Width': bottom_width, 'Top Width': top_width, 'Offset': offset, 'Bottom Height': bottom_height, 'Top Height': top_height, 'Point 1': point_1, 'Point 2': point_2, 'Point 3': point_3, 'Point 4': point_4}, mode=mode)
        return node._out


    @classmethod
    def quadratic_bezier(cls, resolution=None, start=None, middle=None, end=None):
        """ > Node <&Node Quadratic Bzier>

        Arguments
        ---------
        - resolution (Integer) : socket 'Resolution'
        - start (Vector) : socket 'Start'
        - middle (Vector) : socket 'Middle'
        - end (Vector) : socket 'End'

        Returns
        -------
        - Geometry
        """
        node = Node('Quadratic Bzier', {'Resolution': resolution, 'Start': start, 'Middle': middle, 'End': end})
        return node._out


    @classmethod
    def set_handle_type(cls, curve=None, selection=None, handle_type='AUTO', mode={'LEFT', 'RIGHT'}):
        """ > Node <&Node Set Handle Type>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - handle_type (str): parameter 'handle_type' in ('FREE', 'AUTO', 'VECTOR', 'ALIGN')
        - mode (set): parameter 'mode'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Handle Type', {'Curve': curve, 'Selection': selection}, handle_type=handle_type, mode=mode)
        return node._out


    @classmethod
    def spiral(cls, resolution=None, rotations=None, start_radius=None, end_radius=None, height=None, reverse=None):
        """ > Node <&Node Spiral>

        Arguments
        ---------
        - resolution (Integer) : socket 'Resolution'
        - rotations (Float) : socket 'Rotations'
        - start_radius (Float) : socket 'Start Radius'
        - end_radius (Float) : socket 'End Radius'
        - height (Float) : socket 'Height'
        - reverse (Boolean) : socket 'Reverse'

        Returns
        -------
        - Geometry
        """
        node = Node('Spiral', {'Resolution': resolution, 'Rotations': rotations, 'Start Radius': start_radius, 'End Radius': end_radius, 'Height': height, 'Reverse': reverse})
        return node._out


    @classmethod
    def set_spline_type(cls, curve=None, selection=None, spline_type='POLY'):
        """ > Node <&Node Set Spline Type>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - spline_type (str): parameter 'spline_type' in ('CATMULL_ROM', 'POLY', 'BEZIER', 'NURBS')

        Returns
        -------
        - Geometry
        """
        node = Node('Set Spline Type', {'Curve': curve, 'Selection': selection}, spline_type=spline_type)
        return node._out


    @classmethod
    def star(cls, points=None, inner_radius=None, outer_radius=None, twist=None):
        """ > Node <&Node Star>

        Arguments
        ---------
        - points (Integer) : socket 'Points'
        - inner_radius (Float) : socket 'Inner Radius'
        - outer_radius (Float) : socket 'Outer Radius'
        - twist (Float) : socket 'Twist'

        Returns
        -------
        - Node : 'Star'
        """
        node = Node('Star', {'Points': points, 'Inner Radius': inner_radius, 'Outer Radius': outer_radius, 'Twist': twist})
        return node


    @classmethod
    def curve_to_mesh(cls, curve=None, profile_curve=None, fill_caps=None):
        """ > Node <&Node Curve to Mesh>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - profile_curve (Geometry) : socket 'Profile Curve'
        - fill_caps (Boolean) : socket 'Fill Caps'

        Returns
        -------
        - Geometry
        """
        node = Node('Curve to Mesh', {'Curve': curve, 'Profile Curve': profile_curve, 'Fill Caps': fill_caps})
        return node._out


    @classmethod
    def curve_to_points(cls, curve=None, count=None, length=None, mode='COUNT'):
        """ > Node <&Node Curve to Points>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - count (Integer) : socket 'Count'
        - length (Float) : socket 'Length'
        - mode (str): parameter 'mode' in ('EVALUATED', 'COUNT', 'LENGTH')

        Returns
        -------
        - Node : 'Curve to Points'
        """
        node = Node('Curve to Points', {'Curve': curve, 'Count': count, 'Length': length}, mode=mode)
        return node


    @classmethod
    def curves_to_grease_pencil(cls, curves=None, selection=None, instances_as_layers=None):
        """ > Node <&Node Curves to Grease Pencil>

        Arguments
        ---------
        - curves (Geometry) : socket 'Curves'
        - selection (Boolean) : socket 'Selection'
        - instances_as_layers (Boolean) : socket 'Instances as Layers'

        Returns
        -------
        - Geometry
        """
        node = Node('Curves to Grease Pencil', {'Curves': curves, 'Selection': selection, 'Instances as Layers': instances_as_layers})
        return node._out


    @classmethod
    def deform_curves_on_surface(cls, curves=None):
        """ > Node <&Node Deform Curves on Surface>

        Arguments
        ---------
        - curves (Geometry) : socket 'Curves'

        Returns
        -------
        - Geometry
        """
        node = Node('Deform Curves on Surface', {'Curves': curves})
        return node._out


    @classmethod
    def delete_geometry(cls, geometry=None, selection=None, domain='POINT', mode='ALL'):
        """ > Node <&Node Delete Geometry>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CURVE', 'INSTANCE', 'LAYER')
        - mode (str): parameter 'mode' in ('ALL', 'EDGE_FACE', 'ONLY_FACE')

        Returns
        -------
        - Geometry
        """
        node = Node('Delete Geometry', {'Geometry': geometry, 'Selection': selection}, domain=domain, mode=mode)
        return node._out


    @classmethod
    def distribute_points_in_grid(cls, grid=None, density=None, seed=None, spacing=None, threshold=None, mode='DENSITY_RANDOM'):
        """ > Node <&Node Distribute Points in Grid>

        Arguments
        ---------
        - grid (Float) : socket 'Grid'
        - density (Float) : socket 'Density'
        - seed (Integer) : socket 'Seed'
        - spacing (Vector) : socket 'Spacing'
        - threshold (Float) : socket 'Threshold'
        - mode (str): parameter 'mode' in ('DENSITY_RANDOM', 'DENSITY_GRID')

        Returns
        -------
        - Geometry
        """
        node = Node('Distribute Points in Grid', {'Grid': grid, 'Density': density, 'Seed': seed, 'Spacing': spacing, 'Threshold': threshold}, mode=mode)
        return node._out


    @classmethod
    def distribute_points_in_volume(cls, volume=None, density=None, seed=None, spacing=None, threshold=None, mode='DENSITY_RANDOM'):
        """ > Node <&Node Distribute Points in Volume>

        Arguments
        ---------
        - volume (Geometry) : socket 'Volume'
        - density (Float) : socket 'Density'
        - seed (Integer) : socket 'Seed'
        - spacing (Vector) : socket 'Spacing'
        - threshold (Float) : socket 'Threshold'
        - mode (str): parameter 'mode' in ('DENSITY_RANDOM', 'DENSITY_GRID')

        Returns
        -------
        - Geometry
        """
        node = Node('Distribute Points in Volume', {'Volume': volume, 'Density': density, 'Seed': seed, 'Spacing': spacing, 'Threshold': threshold}, mode=mode)
        return node._out


    @classmethod
    def distribute_points_on_faces(cls, mesh=None, selection=None, distance_min=None, density_max=None, density=None, density_factor=None, seed=None, distribute_method='RANDOM', use_legacy_normal=False):
        """ > Node <&Node Distribute Points on Faces>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'
        - distance_min (Float) : socket 'Distance Min'
        - density_max (Float) : socket 'Density Max'
        - density (Float) : socket 'Density'
        - density_factor (Float) : socket 'Density Factor'
        - seed (Integer) : socket 'Seed'
        - distribute_method (str): parameter 'distribute_method' in ('RANDOM', 'POISSON')
        - use_legacy_normal (bool): parameter 'use_legacy_normal'

        Returns
        -------
        - Node : 'Distribute Points on Faces'
        """
        node = Node('Distribute Points on Faces', {'Mesh': mesh, 'Selection': selection, 'Distance Min': distance_min, 'Density Max': density_max, 'Density': density, 'Density Factor': density_factor, 'Seed': seed}, distribute_method=distribute_method, use_legacy_normal=use_legacy_normal)
        return node


    @classmethod
    def dual_mesh(cls, mesh=None, keep_boundaries=None):
        """ > Node <&Node Dual Mesh>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - keep_boundaries (Boolean) : socket 'Keep Boundaries'

        Returns
        -------
        - Geometry
        """
        node = Node('Dual Mesh', {'Mesh': mesh, 'Keep Boundaries': keep_boundaries})
        return node._out


    @classmethod
    def duplicate_elements(cls, geometry=None, selection=None, amount=None, domain='POINT'):
        """ > Node <&Node Duplicate Elements>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - amount (Integer) : socket 'Amount'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'SPLINE', 'LAYER', 'INSTANCE')

        Returns
        -------
        - Node : 'Duplicate Elements'
        """
        node = Node('Duplicate Elements', {'Geometry': geometry, 'Selection': selection, 'Amount': amount}, domain=domain)
        return node


    @classmethod
    def edge_paths_to_curves(cls, mesh=None, start_vertices=None, next_vertex_index=None):
        """ > Node <&Node Edge Paths to Curves>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - start_vertices (Boolean) : socket 'Start Vertices'
        - next_vertex_index (Integer) : socket 'Next Vertex Index'

        Returns
        -------
        - Geometry
        """
        node = Node('Edge Paths to Curves', {'Mesh': mesh, 'Start Vertices': start_vertices, 'Next Vertex Index': next_vertex_index})
        return node._out


    @classmethod
    def edge_paths_to_selection(cls, start_vertices=None, next_vertex_index=None):
        """ > Node <&Node Edge Paths to Selection>

        Arguments
        ---------
        - start_vertices (Boolean) : socket 'Start Vertices'
        - next_vertex_index (Integer) : socket 'Next Vertex Index'

        Returns
        -------
        - Boolean
        """
        node = Node('Edge Paths to Selection', {'Start Vertices': start_vertices, 'Next Vertex Index': next_vertex_index})
        return node._out


    @classmethod
    def edges_of_corner(cls, corner_index=None):
        """ > Node <&Node Edges of Corner>

        Arguments
        ---------
        - corner_index (Integer) : socket 'Corner Index'

        Returns
        -------
        - Node : 'Edges of Corner'
        """
        node = Node('Edges of Corner', {'Corner Index': corner_index})
        return node


    @classmethod
    def edges_of_vertex(cls, vertex_index=None, weights=None, sort_index=None):
        """ > Node <&Node Edges of Vertex>

        Arguments
        ---------
        - vertex_index (Integer) : socket 'Vertex Index'
        - weights (Float) : socket 'Weights'
        - sort_index (Integer) : socket 'Sort Index'

        Returns
        -------
        - Node : 'Edges of Vertex'
        """
        node = Node('Edges of Vertex', {'Vertex Index': vertex_index, 'Weights': weights, 'Sort Index': sort_index})
        return node


    @classmethod
    def edges_to_face_groups(cls, boundary_edges=None):
        """ > Node <&Node Edges to Face Groups>

        Arguments
        ---------
        - boundary_edges (Boolean) : socket 'Boundary Edges'

        Returns
        -------
        - Integer
        """
        node = Node('Edges to Face Groups', {'Boundary Edges': boundary_edges})
        return node._out


    @classmethod
    def extrude_mesh(cls, mesh=None, selection=None, offset=None, offset_scale=None, individual=None, mode='FACES'):
        """ > Node <&Node Extrude Mesh>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'
        - offset (Vector) : socket 'Offset'
        - offset_scale (Float) : socket 'Offset Scale'
        - individual (Boolean) : socket 'Individual'
        - mode (str): parameter 'mode' in ('VERTICES', 'EDGES', 'FACES')

        Returns
        -------
        - Node : 'Extrude Mesh'
        """
        node = Node('Extrude Mesh', {'Mesh': mesh, 'Selection': selection, 'Offset': offset, 'Offset Scale': offset_scale, 'Individual': individual}, mode=mode)
        return node


    @classmethod
    def face_of_corner(cls, corner_index=None):
        """ > Node <&Node Face of Corner>

        Arguments
        ---------
        - corner_index (Integer) : socket 'Corner Index'

        Returns
        -------
        - Node : 'Face of Corner'
        """
        node = Node('Face of Corner', {'Corner Index': corner_index})
        return node


    @classmethod
    def evaluate_at_index(cls, index=None, value=None, data_type='FLOAT', domain='POINT'):
        """ > Node <&Node Evaluate at Index>

        Arguments
        ---------
        - index (Integer) : socket 'Index'
        - value (Float) : socket 'Value'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Float
        """
        node = Node('Evaluate at Index', {'Index': index, 'Value': value}, data_type=data_type, domain=domain)
        return node._out


    @classmethod
    def evaluate_on_domain(cls, value=None, data_type='FLOAT', domain='POINT'):
        """ > Node <&Node Evaluate on Domain>

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Float
        """
        node = Node('Evaluate on Domain', {'Value': value}, data_type=data_type, domain=domain)
        return node._out


    @classmethod
    def fill_curve(cls, curve=None, group_id=None, mode='TRIANGLES'):
        """ > Node <&Node Fill Curve>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - group_id (Integer) : socket 'Group ID'
        - mode (str): parameter 'mode' in ('TRIANGLES', 'NGONS')

        Returns
        -------
        - Geometry
        """
        node = Node('Fill Curve', {'Curve': curve, 'Group ID': group_id}, mode=mode)
        return node._out


    @classmethod
    def fillet_curve(cls, curve=None, count=None, radius=None, limit_radius=None, mode='BEZIER'):
        """ > Node <&Node Fillet Curve>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - count (Integer) : socket 'Count'
        - radius (Float) : socket 'Radius'
        - limit_radius (Boolean) : socket 'Limit Radius'
        - mode (str): parameter 'mode' in ('BEZIER', 'POLY')

        Returns
        -------
        - Geometry
        """
        node = Node('Fillet Curve', {'Curve': curve, 'Count': count, 'Radius': radius, 'Limit Radius': limit_radius}, mode=mode)
        return node._out


    @classmethod
    def flip_faces(cls, mesh=None, selection=None):
        """ > Node <&Node Flip Faces>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'

        Returns
        -------
        - Geometry
        """
        node = Node('Flip Faces', {'Mesh': mesh, 'Selection': selection})
        return node._out


    @classmethod
    def for_each_geometry_element_input(cls, geometry=None, selection=None, pair_with_output=None, paired_output=None):
        """ > Node <&Node For Each Geometry Element Input>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - pair_with_output (bpy_func): parameter 'pair_with_output'
        - paired_output (NoneType): parameter 'paired_output'

        Returns
        -------
        - Node : 'For Each Geometry Element Input'
        """
        node = Node('For Each Geometry Element Input', {'Geometry': geometry, 'Selection': selection}, pair_with_output=pair_with_output, paired_output=paired_output)
        return node


    @classmethod
    def for_each_geometry_element_output(cls, geometry=None, active_generation_index=0, active_input_index=0, active_main_index=0, domain='POINT', inspection_index=0):
        """ > Node <&Node For Each Geometry Element Output>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - active_generation_index (int): parameter 'active_generation_index'
        - active_input_index (int): parameter 'active_input_index'
        - active_main_index (int): parameter 'active_main_index'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')
        - inspection_index (int): parameter 'inspection_index'

        Returns
        -------
        - Node : 'For Each Geometry Element Output'
        """
        node = Node('For Each Geometry Element Output', {'Geometry': geometry}, active_generation_index=active_generation_index, active_input_index=active_input_index, active_main_index=active_main_index, domain=domain, inspection_index=inspection_index)
        return node


    @classmethod
    def geometry_to_instance(cls, geometry=None):
        """ > Node <&Node Geometry to Instance>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Geometry
        """
        node = Node('Geometry to Instance', {'Geometry': geometry})
        return node._out


    @classmethod
    def get_named_grid(cls, volume=None, name=None, remove=None, data_type='FLOAT'):
        """ > Node <&Node Get Named Grid>

        Arguments
        ---------
        - volume (Geometry) : socket 'Volume'
        - name (String) : socket 'Name'
        - remove (Boolean) : socket 'Remove'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'VECTOR')

        Returns
        -------
        - Node : 'Get Named Grid'
        """
        node = Node('Get Named Grid', {'Volume': volume, 'Name': name, 'Remove': remove}, data_type=data_type)
        return node


    @classmethod
    def dial_gizmo(cls, value=None, position=None, up=None, screen_space=None, radius=None, color_id='PRIMARY'):
        """ > Node <&Node Dial Gizmo>

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - position (Vector) : socket 'Position'
        - up (Vector) : socket 'Up'
        - screen_space (Boolean) : socket 'Screen Space'
        - radius (Float) : socket 'Radius'
        - color_id (str): parameter 'color_id' in ('PRIMARY', 'SECONDARY', 'X', 'Y', 'Z')

        Returns
        -------
        - Geometry
        """
        node = Node('Dial Gizmo', {'Value': value, 'Position': position, 'Up': up, 'Screen Space': screen_space, 'Radius': radius}, color_id=color_id)
        return node._out


    @classmethod
    def linear_gizmo(cls, value=None, position=None, direction=None, color_id='PRIMARY', draw_style='ARROW'):
        """ > Node <&Node Linear Gizmo>

        Arguments
        ---------
        - value (Float) : socket 'Value'
        - position (Vector) : socket 'Position'
        - direction (Vector) : socket 'Direction'
        - color_id (str): parameter 'color_id' in ('PRIMARY', 'SECONDARY', 'X', 'Y', 'Z')
        - draw_style (str): parameter 'draw_style' in ('ARROW', 'CROSS', 'BOX')

        Returns
        -------
        - Geometry
        """
        node = Node('Linear Gizmo', {'Value': value, 'Position': position, 'Direction': direction}, color_id=color_id, draw_style=draw_style)
        return node._out


    @classmethod
    def transform_gizmo(cls, value=None, position=None, rotation=None, use_rotation_x=True, use_rotation_y=True, use_rotation_z=True, use_scale_x=True, use_scale_y=True, use_scale_z=True, use_translation_x=True, use_translation_y=True, use_translation_z=True):
        """ > Node <&Node Transform Gizmo>

        Arguments
        ---------
        - value (Matrix) : socket 'Value'
        - position (Vector) : socket 'Position'
        - rotation (Rotation) : socket 'Rotation'
        - use_rotation_x (bool): parameter 'use_rotation_x'
        - use_rotation_y (bool): parameter 'use_rotation_y'
        - use_rotation_z (bool): parameter 'use_rotation_z'
        - use_scale_x (bool): parameter 'use_scale_x'
        - use_scale_y (bool): parameter 'use_scale_y'
        - use_scale_z (bool): parameter 'use_scale_z'
        - use_translation_x (bool): parameter 'use_translation_x'
        - use_translation_y (bool): parameter 'use_translation_y'
        - use_translation_z (bool): parameter 'use_translation_z'

        Returns
        -------
        - Geometry
        """
        node = Node('Transform Gizmo', {'Value': value, 'Position': position, 'Rotation': rotation}, use_rotation_x=use_rotation_x, use_rotation_y=use_rotation_y, use_rotation_z=use_rotation_z, use_scale_x=use_scale_x, use_scale_y=use_scale_y, use_scale_z=use_scale_z, use_translation_x=use_translation_x, use_translation_y=use_translation_y, use_translation_z=use_translation_z)
        return node._out


    @classmethod
    def grease_pencil_to_curves(cls, grease_pencil=None, selection=None, layers_as_instances=None):
        """ > Node <&Node Grease Pencil to Curves>

        Arguments
        ---------
        - grease_pencil (Geometry) : socket 'Grease Pencil'
        - selection (Boolean) : socket 'Selection'
        - layers_as_instances (Boolean) : socket 'Layers as Instances'

        Returns
        -------
        - Geometry
        """
        node = Node('Grease Pencil to Curves', {'Grease Pencil': grease_pencil, 'Selection': selection, 'Layers as Instances': layers_as_instances})
        return node._out


    @classmethod
    def grid_to_mesh(cls, grid=None, threshold=None, adaptivity=None):
        """ > Node <&Node Grid to Mesh>

        Arguments
        ---------
        - grid (Float) : socket 'Grid'
        - threshold (Float) : socket 'Threshold'
        - adaptivity (Float) : socket 'Adaptivity'

        Returns
        -------
        - Geometry
        """
        node = Node('Grid to Mesh', {'Grid': grid, 'Threshold': threshold, 'Adaptivity': adaptivity})
        return node._out


    @classmethod
    def group(cls, node_tree=None):
        """ > Node <&Node Group>

        Arguments
        ---------
        - node_tree (NoneType): parameter 'node_tree'

        Returns
        -------
        - Node : 'Group'
        """
        node = Node('Group', node_tree=node_tree)
        return node


    @classmethod
    def image_info(cls, image=None, frame=None):
        """ > Node <&Node Image Info>

        Arguments
        ---------
        - image (Image) : socket 'Image'
        - frame (Integer) : socket 'Frame'

        Returns
        -------
        - Node : 'Image Info'
        """
        node = Node('Image Info', {'Image': image, 'Frame': frame})
        return node


    @classmethod
    def image_texture(cls, image=None, vector=None, frame=None, extension='REPEAT', interpolation='Linear'):
        """ > Node <&Node Image Texture>

        Arguments
        ---------
        - image (Image) : socket 'Image'
        - vector (Vector) : socket 'Vector'
        - frame (Integer) : socket 'Frame'
        - extension (str): parameter 'extension' in ('REPEAT', 'EXTEND', 'CLIP', 'MIRROR')
        - interpolation (str): parameter 'interpolation' in ('Linear', 'Closest', 'Cubic')

        Returns
        -------
        - Node : 'Image Texture'
        """
        node = Node('Image Texture', {'Image': image, 'Vector': vector, 'Frame': frame}, extension=extension, interpolation=interpolation)
        return node


    @classmethod
    def import_obj(cls, path=None):
        """ > Node <&Node Import OBJ>

        Arguments
        ---------
        - path (String) : socket 'Path'

        Returns
        -------
        - Geometry
        """
        node = Node('Import OBJ', {'Path': path})
        return node._out


    @classmethod
    def import_ply(cls, path=None):
        """ > Node <&Node Import PLY>

        Arguments
        ---------
        - path (String) : socket 'Path'

        Returns
        -------
        - Geometry
        """
        node = Node('Import PLY', {'Path': path})
        return node._out


    @classmethod
    def import_stl(cls, path=None):
        """ > Node <&Node Import STL>

        Arguments
        ---------
        - path (String) : socket 'Path'

        Returns
        -------
        - Geometry
        """
        node = Node('Import STL', {'Path': path})
        return node._out


    @classmethod
    def index_of_nearest(cls, position=None, group_id=None):
        """ > Node <&Node Index of Nearest>

        Arguments
        ---------
        - position (Vector) : socket 'Position'
        - group_id (Integer) : socket 'Group ID'

        Returns
        -------
        - Node : 'Index of Nearest'
        """
        node = Node('Index of Nearest', {'Position': position, 'Group ID': group_id})
        return node


    @classmethod
    def index_switch(cls, index=None, _0=None, _1=None, data_type='GEOMETRY'):
        """ > Node <&Node Index Switch>

        Arguments
        ---------
        - index (Integer) : socket 'Index'
        - _0 (Geometry) : socket '0'
        - _1 (Geometry) : socket '1'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'BOOLEAN', 'VECTOR', 'ROTATION', 'MATRIX', 'STRING', 'MENU', 'RGBA', 'OBJECT', 'IMAGE', 'GEOMETRY', 'COLLECTION', 'MATERIAL')

        Returns
        -------
        - Geometry
        """
        node = Node('Index Switch', {'Index': index, '0': _0, '1': _1}, data_type=data_type)
        return node._out


    @classmethod
    @property
    def active_camera(cls):
        """ > Node <&Node Active Camera>

        Returns
        -------
        - Object
        """
        node = Node('Active Camera')
        return node._out


    @classmethod
    def curve_handle_positions(cls, relative=None):
        """ > Node <&Node Curve Handle Positions>

        Arguments
        ---------
        - relative (Boolean) : socket 'Relative'

        Returns
        -------
        - Node : 'Curve Handle Positions'
        """
        node = Node('Curve Handle Positions', {'Relative': relative})
        return node


    @classmethod
    @property
    def curve_tilt(cls):
        """ > Node <&Node Curve Tilt>

        Returns
        -------
        - Float
        """
        node = Node('Curve Tilt')
        return node._out


    @classmethod
    @property
    def is_edge_smooth(cls):
        """ > Node <&Node Is Edge Smooth>

        Returns
        -------
        - Boolean
        """
        node = Node('Is Edge Smooth')
        return node._out


    @classmethod
    @property
    def id(cls):
        """ > Node <&Node ID>

        Returns
        -------
        - Integer
        """
        node = Node('ID')
        return node._out


    @classmethod
    def image(cls, image=None):
        """ > Node <&Node Image>

        Arguments
        ---------
        - image (NoneType): parameter 'image'

        Returns
        -------
        - Image
        """
        node = Node('Image', image=image)
        return node._out


    @classmethod
    @property
    def index(cls):
        """ > Node <&Node Index>

        Returns
        -------
        - Integer
        """
        node = Node('Index')
        return node._out


    @classmethod
    @property
    def instance_rotation(cls):
        """ > Node <&Node Instance Rotation>

        Returns
        -------
        - Rotation
        """
        node = Node('Instance Rotation')
        return node._out


    @classmethod
    @property
    def instance_scale(cls):
        """ > Node <&Node Instance Scale>

        Returns
        -------
        - Vector
        """
        node = Node('Instance Scale')
        return node._out


    @classmethod
    def material(cls, material=None):
        """ > Node <&Node Material>

        Arguments
        ---------
        - material (NoneType): parameter 'material'

        Returns
        -------
        - Material
        """
        node = Node('Material', material=material)
        return node._out


    @classmethod
    @property
    def material_index(cls):
        """ > Node <&Node Material Index>

        Returns
        -------
        - Integer
        """
        node = Node('Material Index')
        return node._out


    @classmethod
    @property
    def edge_angle(cls):
        """ > Node <&Node Edge Angle>

        Returns
        -------
        - Node : 'Edge Angle'
        """
        node = Node('Edge Angle')
        return node


    @classmethod
    @property
    def edge_neighbors(cls):
        """ > Node <&Node Edge Neighbors>

        Returns
        -------
        - Integer
        """
        node = Node('Edge Neighbors')
        return node._out


    @classmethod
    @property
    def edge_vertices(cls):
        """ > Node <&Node Edge Vertices>

        Returns
        -------
        - Node : 'Edge Vertices'
        """
        node = Node('Edge Vertices')
        return node


    @classmethod
    @property
    def face_area(cls):
        """ > Node <&Node Face Area>

        Returns
        -------
        - Float
        """
        node = Node('Face Area')
        return node._out


    @classmethod
    def is_face_planar(cls, threshold=None):
        """ > Node <&Node Is Face Planar>

        Arguments
        ---------
        - threshold (Float) : socket 'Threshold'

        Returns
        -------
        - Boolean
        """
        node = Node('Is Face Planar', {'Threshold': threshold})
        return node._out


    @classmethod
    @property
    def face_neighbors(cls):
        """ > Node <&Node Face Neighbors>

        Returns
        -------
        - Node : 'Face Neighbors'
        """
        node = Node('Face Neighbors')
        return node


    @classmethod
    @property
    def mesh_island(cls):
        """ > Node <&Node Mesh Island>

        Returns
        -------
        - Node : 'Mesh Island'
        """
        node = Node('Mesh Island')
        return node


    @classmethod
    @property
    def vertex_neighbors(cls):
        """ > Node <&Node Vertex Neighbors>

        Returns
        -------
        - Node : 'Vertex Neighbors'
        """
        node = Node('Vertex Neighbors')
        return node


    @classmethod
    def named_attribute(cls, name=None, data_type='FLOAT'):
        """ > Node <&Node Named Attribute>

        Arguments
        ---------
        - name (String) : socket 'Name'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')

        Returns
        -------
        - Node : 'Named Attribute'
        """
        node = Node('Named Attribute', {'Name': name}, data_type=data_type)
        return node


    @classmethod
    def named_layer_selection(cls, name=None):
        """ > Node <&Node Named Layer Selection>

        Arguments
        ---------
        - name (String) : socket 'Name'

        Returns
        -------
        - Boolean
        """
        node = Node('Named Layer Selection', {'Name': name})
        return node._out


    @classmethod
    @property
    def normal(cls):
        """ > Node <&Node Normal>

        Returns
        -------
        - Vector
        """
        node = Node('Normal')
        return node._out


    @classmethod
    @property
    def position(cls):
        """ > Node <&Node Position>

        Returns
        -------
        - Vector
        """
        node = Node('Position')
        return node._out


    @classmethod
    @property
    def radius(cls):
        """ > Node <&Node Radius>

        Returns
        -------
        - Float
        """
        node = Node('Radius')
        return node._out


    @classmethod
    @property
    def scene_time(cls):
        """ > Node <&Node Scene Time>

        Returns
        -------
        - Node : 'Scene Time'
        """
        node = Node('Scene Time')
        return node


    @classmethod
    @property
    def is_face_smooth(cls):
        """ > Node <&Node Is Face Smooth>

        Returns
        -------
        - Boolean
        """
        node = Node('Is Face Smooth')
        return node._out


    @classmethod
    def shortest_edge_paths(cls, end_vertex=None, edge_cost=None):
        """ > Node <&Node Shortest Edge Paths>

        Arguments
        ---------
        - end_vertex (Boolean) : socket 'End Vertex'
        - edge_cost (Float) : socket 'Edge Cost'

        Returns
        -------
        - Node : 'Shortest Edge Paths'
        """
        node = Node('Shortest Edge Paths', {'End Vertex': end_vertex, 'Edge Cost': edge_cost})
        return node


    @classmethod
    @property
    def is_spline_cyclic(cls):
        """ > Node <&Node Is Spline Cyclic>

        Returns
        -------
        - Boolean
        """
        node = Node('Is Spline Cyclic')
        return node._out


    @classmethod
    @property
    def spline_resolution(cls):
        """ > Node <&Node Spline Resolution>

        Returns
        -------
        - Integer
        """
        node = Node('Spline Resolution')
        return node._out


    @classmethod
    @property
    def curve_tangent(cls):
        """ > Node <&Node Curve Tangent>

        Returns
        -------
        - Vector
        """
        node = Node('Curve Tangent')
        return node._out


    @classmethod
    def instance_on_points(cls, points=None, selection=None, instance=None, pick_instance=None, instance_index=None, rotation=None, scale=None):
        """ > Node <&Node Instance on Points>

        Arguments
        ---------
        - points (Geometry) : socket 'Points'
        - selection (Boolean) : socket 'Selection'
        - instance (Geometry) : socket 'Instance'
        - pick_instance (Boolean) : socket 'Pick Instance'
        - instance_index (Integer) : socket 'Instance Index'
        - rotation (Rotation) : socket 'Rotation'
        - scale (Vector) : socket 'Scale'

        Returns
        -------
        - Geometry
        """
        node = Node('Instance on Points', {'Points': points, 'Selection': selection, 'Instance': instance, 'Pick Instance': pick_instance, 'Instance Index': instance_index, 'Rotation': rotation, 'Scale': scale})
        return node._out


    @classmethod
    @property
    def instance_transform(cls):
        """ > Node <&Node Instance Transform>

        Returns
        -------
        - Matrix
        """
        node = Node('Instance Transform')
        return node._out


    @classmethod
    def instances_to_points(cls, instances=None, selection=None, position=None, radius=None):
        """ > Node <&Node Instances to Points>

        Arguments
        ---------
        - instances (Geometry) : socket 'Instances'
        - selection (Boolean) : socket 'Selection'
        - position (Vector) : socket 'Position'
        - radius (Float) : socket 'Radius'

        Returns
        -------
        - Geometry
        """
        node = Node('Instances to Points', {'Instances': instances, 'Selection': selection, 'Position': position, 'Radius': radius})
        return node._out


    @classmethod
    def interpolate_curves(cls, guide_curves=None, guide_up=None, guide_group_id=None, points=None, point_up=None, point_group_id=None, max_neighbors=None):
        """ > Node <&Node Interpolate Curves>

        Arguments
        ---------
        - guide_curves (Geometry) : socket 'Guide Curves'
        - guide_up (Vector) : socket 'Guide Up'
        - guide_group_id (Integer) : socket 'Guide Group ID'
        - points (Geometry) : socket 'Points'
        - point_up (Vector) : socket 'Point Up'
        - point_group_id (Integer) : socket 'Point Group ID'
        - max_neighbors (Integer) : socket 'Max Neighbors'

        Returns
        -------
        - Node : 'Interpolate Curves'
        """
        node = Node('Interpolate Curves', {'Guide Curves': guide_curves, 'Guide Up': guide_up, 'Guide Group ID': guide_group_id, 'Points': points, 'Point Up': point_up, 'Point Group ID': point_group_id, 'Max Neighbors': max_neighbors})
        return node


    @classmethod
    @property
    def is_viewport(cls):
        """ > Node <&Node Is Viewport>

        Returns
        -------
        - Boolean
        """
        node = Node('Is Viewport')
        return node._out


    @classmethod
    def join_geometry(cls, geometry=None):
        """ > Node <&Node Join Geometry>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Geometry
        """
        node = Node('Join Geometry', {'Geometry': geometry})
        return node._out


    @classmethod
    def material_selection(cls, material=None):
        """ > Node <&Node Material Selection>

        Arguments
        ---------
        - material (Material) : socket 'Material'

        Returns
        -------
        - Boolean
        """
        node = Node('Material Selection', {'Material': material})
        return node._out


    @classmethod
    def menu_switch(cls, _items={}, menu=None, a=None, b=None, data_type='GEOMETRY', enum_definition=None):
        """ > Node <&Node Menu Switch>

        Arguments
        ---------
        - items (dict) : items to create
        - menu (Menu) : socket 'Menu'
        - a (Geometry) : socket 'A'
        - b (Geometry) : socket 'B'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'BOOLEAN', 'VECTOR', 'ROTATION', 'MATRIX', 'STRING', 'RGBA', 'OBJECT', 'IMAGE', 'GEOMETRY', 'COLLECTION', 'MATERIAL')
        - enum_definition (GeometryNodeMenuSwitch): parameter 'enum_definition'

        Returns
        -------
        - Geometry
        """
        node = Node('Menu Switch', {'Menu': menu, 'A': a, 'B': b}, _items=_items, data_type=data_type, enum_definition=enum_definition)
        return node._out


    @classmethod
    def merge_by_distance(cls, geometry=None, selection=None, distance=None, mode='ALL'):
        """ > Node <&Node Merge by Distance>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - distance (Float) : socket 'Distance'
        - mode (str): parameter 'mode' in ('ALL', 'CONNECTED')

        Returns
        -------
        - Geometry
        """
        node = Node('Merge by Distance', {'Geometry': geometry, 'Selection': selection, 'Distance': distance}, mode=mode)
        return node._out


    @classmethod
    def merge_layers(cls, grease_pencil=None, selection=None, group_id=None, mode='MERGE_BY_NAME'):
        """ > Node <&Node Merge Layers>

        Arguments
        ---------
        - grease_pencil (Geometry) : socket 'Grease Pencil'
        - selection (Boolean) : socket 'Selection'
        - group_id (Integer) : socket 'Group ID'
        - mode (str): parameter 'mode' in ('MERGE_BY_NAME', 'MERGE_BY_ID')

        Returns
        -------
        - Geometry
        """
        node = Node('Merge Layers', {'Grease Pencil': grease_pencil, 'Selection': selection, 'Group ID': group_id}, mode=mode)
        return node._out


    @classmethod
    def mesh_boolean(cls, mesh_1=None, mesh_2=None, self_intersection=None, hole_tolerant=None, operation='DIFFERENCE', solver='FLOAT'):
        """ > Node <&Node Mesh Boolean>

        Arguments
        ---------
        - mesh_1 (Geometry) : socket 'Mesh 1'
        - mesh_2 (Geometry) : socket 'Mesh 2'
        - self_intersection (Boolean) : socket 'Self Intersection'
        - hole_tolerant (Boolean) : socket 'Hole Tolerant'
        - operation (str): parameter 'operation' in ('INTERSECT', 'UNION', 'DIFFERENCE')
        - solver (str): parameter 'solver' in ('EXACT', 'FLOAT')

        Returns
        -------
        - Node : 'Mesh Boolean'
        """
        node = Node('Mesh Boolean', {'Mesh 1': mesh_1, 'Mesh 2': mesh_2, 'Self Intersection': self_intersection, 'Hole Tolerant': hole_tolerant}, operation=operation, solver=solver)
        return node


    @classmethod
    def mesh_circle(cls, vertices=None, radius=None, fill_type='NONE'):
        """ > Node <&Node Mesh Circle>

        Arguments
        ---------
        - vertices (Integer) : socket 'Vertices'
        - radius (Float) : socket 'Radius'
        - fill_type (str): parameter 'fill_type' in ('NONE', 'NGON', 'TRIANGLE_FAN')

        Returns
        -------
        - Geometry
        """
        node = Node('Mesh Circle', {'Vertices': vertices, 'Radius': radius}, fill_type=fill_type)
        return node._out


    @classmethod
    def cone(cls, vertices=None, side_segments=None, fill_segments=None, radius_top=None, radius_bottom=None, depth=None, fill_type='NGON'):
        """ > Node <&Node Cone>

        Arguments
        ---------
        - vertices (Integer) : socket 'Vertices'
        - side_segments (Integer) : socket 'Side Segments'
        - fill_segments (Integer) : socket 'Fill Segments'
        - radius_top (Float) : socket 'Radius Top'
        - radius_bottom (Float) : socket 'Radius Bottom'
        - depth (Float) : socket 'Depth'
        - fill_type (str): parameter 'fill_type' in ('NONE', 'NGON', 'TRIANGLE_FAN')

        Returns
        -------
        - Node : 'Cone'
        """
        node = Node('Cone', {'Vertices': vertices, 'Side Segments': side_segments, 'Fill Segments': fill_segments, 'Radius Top': radius_top, 'Radius Bottom': radius_bottom, 'Depth': depth}, fill_type=fill_type)
        return node


    @classmethod
    def cube(cls, size=None, vertices_x=None, vertices_y=None, vertices_z=None):
        """ > Node <&Node Cube>

        Arguments
        ---------
        - size (Vector) : socket 'Size'
        - vertices_x (Integer) : socket 'Vertices X'
        - vertices_y (Integer) : socket 'Vertices Y'
        - vertices_z (Integer) : socket 'Vertices Z'

        Returns
        -------
        - Node : 'Cube'
        """
        node = Node('Cube', {'Size': size, 'Vertices X': vertices_x, 'Vertices Y': vertices_y, 'Vertices Z': vertices_z})
        return node


    @classmethod
    def cylinder(cls, vertices=None, side_segments=None, fill_segments=None, radius=None, depth=None, fill_type='NGON'):
        """ > Node <&Node Cylinder>

        Arguments
        ---------
        - vertices (Integer) : socket 'Vertices'
        - side_segments (Integer) : socket 'Side Segments'
        - fill_segments (Integer) : socket 'Fill Segments'
        - radius (Float) : socket 'Radius'
        - depth (Float) : socket 'Depth'
        - fill_type (str): parameter 'fill_type' in ('NONE', 'NGON', 'TRIANGLE_FAN')

        Returns
        -------
        - Node : 'Cylinder'
        """
        node = Node('Cylinder', {'Vertices': vertices, 'Side Segments': side_segments, 'Fill Segments': fill_segments, 'Radius': radius, 'Depth': depth}, fill_type=fill_type)
        return node


    @classmethod
    def face_group_boundaries(cls, face_group_id=None):
        """ > Node <&Node Face Group Boundaries>

        Arguments
        ---------
        - face_group_id (Integer) : socket 'Face Group ID'

        Returns
        -------
        - Boolean
        """
        node = Node('Face Group Boundaries', {'Face Group ID': face_group_id})
        return node._out


    @classmethod
    def grid(cls, size_x=None, size_y=None, vertices_x=None, vertices_y=None):
        """ > Node <&Node Grid>

        Arguments
        ---------
        - size_x (Float) : socket 'Size X'
        - size_y (Float) : socket 'Size Y'
        - vertices_x (Integer) : socket 'Vertices X'
        - vertices_y (Integer) : socket 'Vertices Y'

        Returns
        -------
        - Node : 'Grid'
        """
        node = Node('Grid', {'Size X': size_x, 'Size Y': size_y, 'Vertices X': vertices_x, 'Vertices Y': vertices_y})
        return node


    @classmethod
    def ico_sphere(cls, radius=None, subdivisions=None):
        """ > Node <&Node Ico Sphere>

        Arguments
        ---------
        - radius (Float) : socket 'Radius'
        - subdivisions (Integer) : socket 'Subdivisions'

        Returns
        -------
        - Node : 'Ico Sphere'
        """
        node = Node('Ico Sphere', {'Radius': radius, 'Subdivisions': subdivisions})
        return node


    @classmethod
    def mesh_line(cls, count=None, resolution=None, start_location=None, offset=None, count_mode='TOTAL', mode='OFFSET'):
        """ > Node <&Node Mesh Line>

        Arguments
        ---------
        - count (Integer) : socket 'Count'
        - resolution (Float) : socket 'Resolution'
        - start_location (Vector) : socket 'Start Location'
        - offset (Vector) : socket 'Offset'
        - count_mode (str): parameter 'count_mode' in ('TOTAL', 'RESOLUTION')
        - mode (str): parameter 'mode' in ('OFFSET', 'END_POINTS')

        Returns
        -------
        - Geometry
        """
        node = Node('Mesh Line', {'Count': count, 'Resolution': resolution, 'Start Location': start_location, 'Offset': offset}, count_mode=count_mode, mode=mode)
        return node._out


    @classmethod
    def mesh_to_curve(cls, mesh=None, selection=None):
        """ > Node <&Node Mesh to Curve>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'

        Returns
        -------
        - Geometry
        """
        node = Node('Mesh to Curve', {'Mesh': mesh, 'Selection': selection})
        return node._out


    @classmethod
    def mesh_to_density_grid(cls, mesh=None, density=None, voxel_size=None, gradient_width=None):
        """ > Node <&Node Mesh to Density Grid>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - density (Float) : socket 'Density'
        - voxel_size (Float) : socket 'Voxel Size'
        - gradient_width (Float) : socket 'Gradient Width'

        Returns
        -------
        - Float
        """
        node = Node('Mesh to Density Grid', {'Mesh': mesh, 'Density': density, 'Voxel Size': voxel_size, 'Gradient Width': gradient_width})
        return node._out


    @classmethod
    def mesh_to_points(cls, mesh=None, selection=None, position=None, radius=None, mode='VERTICES'):
        """ > Node <&Node Mesh to Points>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'
        - position (Vector) : socket 'Position'
        - radius (Float) : socket 'Radius'
        - mode (str): parameter 'mode' in ('VERTICES', 'EDGES', 'FACES', 'CORNERS')

        Returns
        -------
        - Geometry
        """
        node = Node('Mesh to Points', {'Mesh': mesh, 'Selection': selection, 'Position': position, 'Radius': radius}, mode=mode)
        return node._out


    @classmethod
    def mesh_to_sdf_grid(cls, mesh=None, voxel_size=None, band_width=None):
        """ > Node <&Node Mesh to SDF Grid>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - voxel_size (Float) : socket 'Voxel Size'
        - band_width (Integer) : socket 'Band Width'

        Returns
        -------
        - Float
        """
        node = Node('Mesh to SDF Grid', {'Mesh': mesh, 'Voxel Size': voxel_size, 'Band Width': band_width})
        return node._out


    @classmethod
    def mesh_to_volume(cls, mesh=None, density=None, voxel_size=None, voxel_amount=None, interior_band_width=None, resolution_mode='VOXEL_AMOUNT'):
        """ > Node <&Node Mesh to Volume>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - density (Float) : socket 'Density'
        - voxel_size (Float) : socket 'Voxel Size'
        - voxel_amount (Float) : socket 'Voxel Amount'
        - interior_band_width (Float) : socket 'Interior Band Width'
        - resolution_mode (str): parameter 'resolution_mode' in ('VOXEL_AMOUNT', 'VOXEL_SIZE')

        Returns
        -------
        - Geometry
        """
        node = Node('Mesh to Volume', {'Mesh': mesh, 'Density': density, 'Voxel Size': voxel_size, 'Voxel Amount': voxel_amount, 'Interior Band Width': interior_band_width}, resolution_mode=resolution_mode)
        return node._out


    @classmethod
    def uv_sphere(cls, segments=None, rings=None, radius=None):
        """ > Node <&Node UV Sphere>

        Arguments
        ---------
        - segments (Integer) : socket 'Segments'
        - rings (Integer) : socket 'Rings'
        - radius (Float) : socket 'Radius'

        Returns
        -------
        - Node : 'UV Sphere'
        """
        node = Node('UV Sphere', {'Segments': segments, 'Rings': rings, 'Radius': radius})
        return node


    @classmethod
    def object_info(cls, object=None, as_instance=None, transform_space='ORIGINAL'):
        """ > Node <&Node Object Info>

        Arguments
        ---------
        - object (Object) : socket 'Object'
        - as_instance (Boolean) : socket 'As Instance'
        - transform_space (str): parameter 'transform_space' in ('ORIGINAL', 'RELATIVE')

        Returns
        -------
        - Node : 'Object Info'
        """
        node = Node('Object Info', {'Object': object, 'As Instance': as_instance}, transform_space=transform_space)
        return node


    @classmethod
    def offset_corner_in_face(cls, corner_index=None, offset=None):
        """ > Node <&Node Offset Corner in Face>

        Arguments
        ---------
        - corner_index (Integer) : socket 'Corner Index'
        - offset (Integer) : socket 'Offset'

        Returns
        -------
        - Integer
        """
        node = Node('Offset Corner in Face', {'Corner Index': corner_index, 'Offset': offset})
        return node._out


    @classmethod
    def offset_point_in_curve(cls, point_index=None, offset=None):
        """ > Node <&Node Offset Point in Curve>

        Arguments
        ---------
        - point_index (Integer) : socket 'Point Index'
        - offset (Integer) : socket 'Offset'

        Returns
        -------
        - Node : 'Offset Point in Curve'
        """
        node = Node('Offset Point in Curve', {'Point Index': point_index, 'Offset': offset})
        return node


    @classmethod
    def points(cls, count=None, position=None, radius=None):
        """ > Node <&Node Points>

        Arguments
        ---------
        - count (Integer) : socket 'Count'
        - position (Vector) : socket 'Position'
        - radius (Float) : socket 'Radius'

        Returns
        -------
        - Geometry
        """
        node = Node('Points', {'Count': count, 'Position': position, 'Radius': radius})
        return node._out


    @classmethod
    def points_of_curve(cls, curve_index=None, weights=None, sort_index=None):
        """ > Node <&Node Points of Curve>

        Arguments
        ---------
        - curve_index (Integer) : socket 'Curve Index'
        - weights (Float) : socket 'Weights'
        - sort_index (Integer) : socket 'Sort Index'

        Returns
        -------
        - Node : 'Points of Curve'
        """
        node = Node('Points of Curve', {'Curve Index': curve_index, 'Weights': weights, 'Sort Index': sort_index})
        return node


    @classmethod
    def points_to_curves(cls, points=None, curve_group_id=None, weight=None):
        """ > Node <&Node Points to Curves>

        Arguments
        ---------
        - points (Geometry) : socket 'Points'
        - curve_group_id (Integer) : socket 'Curve Group ID'
        - weight (Float) : socket 'Weight'

        Returns
        -------
        - Geometry
        """
        node = Node('Points to Curves', {'Points': points, 'Curve Group ID': curve_group_id, 'Weight': weight})
        return node._out


    @classmethod
    def points_to_sdf_grid(cls, points=None, radius=None, voxel_size=None):
        """ > Node <&Node Points to SDF Grid>

        Arguments
        ---------
        - points (Geometry) : socket 'Points'
        - radius (Float) : socket 'Radius'
        - voxel_size (Float) : socket 'Voxel Size'

        Returns
        -------
        - Float
        """
        node = Node('Points to SDF Grid', {'Points': points, 'Radius': radius, 'Voxel Size': voxel_size})
        return node._out


    @classmethod
    def points_to_vertices(cls, points=None, selection=None):
        """ > Node <&Node Points to Vertices>

        Arguments
        ---------
        - points (Geometry) : socket 'Points'
        - selection (Boolean) : socket 'Selection'

        Returns
        -------
        - Geometry
        """
        node = Node('Points to Vertices', {'Points': points, 'Selection': selection})
        return node._out


    @classmethod
    def points_to_volume(cls, points=None, density=None, voxel_size=None, voxel_amount=None, radius=None, resolution_mode='VOXEL_AMOUNT'):
        """ > Node <&Node Points to Volume>

        Arguments
        ---------
        - points (Geometry) : socket 'Points'
        - density (Float) : socket 'Density'
        - voxel_size (Float) : socket 'Voxel Size'
        - voxel_amount (Float) : socket 'Voxel Amount'
        - radius (Float) : socket 'Radius'
        - resolution_mode (str): parameter 'resolution_mode' in ('VOXEL_AMOUNT', 'VOXEL_SIZE')

        Returns
        -------
        - Geometry
        """
        node = Node('Points to Volume', {'Points': points, 'Density': density, 'Voxel Size': voxel_size, 'Voxel Amount': voxel_amount, 'Radius': radius}, resolution_mode=resolution_mode)
        return node._out


    @classmethod
    def geometry_proximity(cls, geometry=None, group_id=None, sample_position=None, sample_group_id=None, target_element='FACES'):
        """ > Node <&Node Geometry Proximity>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - group_id (Integer) : socket 'Group ID'
        - sample_position (Vector) : socket 'Sample Position'
        - sample_group_id (Integer) : socket 'Sample Group ID'
        - target_element (str): parameter 'target_element' in ('POINTS', 'EDGES', 'FACES')

        Returns
        -------
        - Node : 'Geometry Proximity'
        """
        node = Node('Geometry Proximity', {'Geometry': geometry, 'Group ID': group_id, 'Sample Position': sample_position, 'Sample Group ID': sample_group_id}, target_element=target_element)
        return node


    @classmethod
    def raycast(cls, target_geometry=None, attribute=None, source_position=None, ray_direction=None, ray_length=None, data_type='FLOAT', mapping='INTERPOLATED'):
        """ > Node <&Node Raycast>

        Arguments
        ---------
        - target_geometry (Geometry) : socket 'Target Geometry'
        - attribute (Float) : socket 'Attribute'
        - source_position (Vector) : socket 'Source Position'
        - ray_direction (Vector) : socket 'Ray Direction'
        - ray_length (Float) : socket 'Ray Length'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')
        - mapping (str): parameter 'mapping' in ('INTERPOLATED', 'NEAREST')

        Returns
        -------
        - Node : 'Raycast'
        """
        node = Node('Raycast', {'Target Geometry': target_geometry, 'Attribute': attribute, 'Source Position': source_position, 'Ray Direction': ray_direction, 'Ray Length': ray_length}, data_type=data_type, mapping=mapping)
        return node


    @classmethod
    def realize_instances(cls, geometry=None, selection=None, realize_all=None, depth=None):
        """ > Node <&Node Realize Instances>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - realize_all (Boolean) : socket 'Realize All'
        - depth (Integer) : socket 'Depth'

        Returns
        -------
        - Geometry
        """
        node = Node('Realize Instances', {'Geometry': geometry, 'Selection': selection, 'Realize All': realize_all, 'Depth': depth})
        return node._out


    @classmethod
    def remove_named_attribute(cls, geometry=None, name=None, pattern_mode='EXACT'):
        """ > Node <&Node Remove Named Attribute>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - name (String) : socket 'Name'
        - pattern_mode (str): parameter 'pattern_mode' in ('EXACT', 'WILDCARD')

        Returns
        -------
        - Geometry
        """
        node = Node('Remove Named Attribute', {'Geometry': geometry, 'Name': name}, pattern_mode=pattern_mode)
        return node._out


    @classmethod
    def repeat_input(cls, iterations=None, pair_with_output=None, paired_output=None):
        """ > Node <&Node Repeat Input>

        Arguments
        ---------
        - iterations (Integer) : socket 'Iterations'
        - pair_with_output (bpy_func): parameter 'pair_with_output'
        - paired_output (NoneType): parameter 'paired_output'

        Returns
        -------
        - Node : 'Repeat Input'
        """
        node = Node('Repeat Input', {'Iterations': iterations}, pair_with_output=pair_with_output, paired_output=paired_output)
        return node


    @classmethod
    def repeat_output(cls, _items={}, geometry=None, inspection_index=0):
        """ > Node <&Node Repeat Output>

        Arguments
        ---------
        - items (dict) : items to create
        - geometry (Geometry) : socket 'Geometry'
        - inspection_index (int): parameter 'inspection_index'

        Returns
        -------
        - Node : 'Repeat Output'
        """
        node = Node('Repeat Output', {'Geometry': geometry}, _items=_items, inspection_index=inspection_index)
        return node


    @classmethod
    def replace_material(cls, geometry=None, old=None, new=None):
        """ > Node <&Node Replace Material>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - old (Material) : socket 'Old'
        - new (Material) : socket 'New'

        Returns
        -------
        - Geometry
        """
        node = Node('Replace Material', {'Geometry': geometry, 'Old': old, 'New': new})
        return node._out


    @classmethod
    def resample_curve(cls, curve=None, selection=None, count=None, length=None, mode='COUNT'):
        """ > Node <&Node Resample Curve>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - count (Integer) : socket 'Count'
        - length (Float) : socket 'Length'
        - mode (str): parameter 'mode' in ('EVALUATED', 'COUNT', 'LENGTH')

        Returns
        -------
        - Geometry
        """
        node = Node('Resample Curve', {'Curve': curve, 'Selection': selection, 'Count': count, 'Length': length}, mode=mode)
        return node._out


    @classmethod
    def reverse_curve(cls, curve=None, selection=None):
        """ > Node <&Node Reverse Curve>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'

        Returns
        -------
        - Geometry
        """
        node = Node('Reverse Curve', {'Curve': curve, 'Selection': selection})
        return node._out


    @classmethod
    def rotate_instances(cls, instances=None, selection=None, rotation=None, pivot_point=None, local_space=None):
        """ > Node <&Node Rotate Instances>

        Arguments
        ---------
        - instances (Geometry) : socket 'Instances'
        - selection (Boolean) : socket 'Selection'
        - rotation (Rotation) : socket 'Rotation'
        - pivot_point (Vector) : socket 'Pivot Point'
        - local_space (Boolean) : socket 'Local Space'

        Returns
        -------
        - Geometry
        """
        node = Node('Rotate Instances', {'Instances': instances, 'Selection': selection, 'Rotation': rotation, 'Pivot Point': pivot_point, 'Local Space': local_space})
        return node._out


    @classmethod
    def sdf_grid_boolean(cls, grid_1=None, grid_2=None, operation='DIFFERENCE'):
        """ > Node <&Node SDF Grid Boolean>

        Arguments
        ---------
        - grid_1 (Float) : socket 'Grid 1'
        - grid_2 (Float) : socket 'Grid 2'
        - operation (str): parameter 'operation' in ('INTERSECT', 'UNION', 'DIFFERENCE')

        Returns
        -------
        - Float
        """
        node = Node('SDF Grid Boolean', {'Grid 1': grid_1, 'Grid 2': grid_2}, operation=operation)
        return node._out


    @classmethod
    def sample_curve(cls, curves=None, value=None, factor=None, length=None, curve_index=None, data_type='FLOAT', mode='FACTOR', use_all_curves=False):
        """ > Node <&Node Sample Curve>

        Arguments
        ---------
        - curves (Geometry) : socket 'Curves'
        - value (Float) : socket 'Value'
        - factor (Float) : socket 'Factor'
        - length (Float) : socket 'Length'
        - curve_index (Integer) : socket 'Curve Index'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')
        - mode (str): parameter 'mode' in ('FACTOR', 'LENGTH')
        - use_all_curves (bool): parameter 'use_all_curves'

        Returns
        -------
        - Node : 'Sample Curve'
        """
        node = Node('Sample Curve', {'Curves': curves, 'Value': value, 'Factor': factor, 'Length': length, 'Curve Index': curve_index}, data_type=data_type, mode=mode, use_all_curves=use_all_curves)
        return node


    @classmethod
    def sample_grid(cls, grid=None, position=None, data_type='FLOAT', interpolation_mode='TRILINEAR'):
        """ > Node <&Node Sample Grid>

        Arguments
        ---------
        - grid (Float) : socket 'Grid'
        - position (Vector) : socket 'Position'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'BOOLEAN', 'VECTOR')
        - interpolation_mode (str): parameter 'interpolation_mode' in ('NEAREST', 'TRILINEAR', 'TRIQUADRATIC')

        Returns
        -------
        - Float
        """
        node = Node('Sample Grid', {'Grid': grid, 'Position': position}, data_type=data_type, interpolation_mode=interpolation_mode)
        return node._out


    @classmethod
    def sample_grid_index(cls, grid=None, x=None, y=None, z=None, data_type='FLOAT'):
        """ > Node <&Node Sample Grid Index>

        Arguments
        ---------
        - grid (Float) : socket 'Grid'
        - x (Integer) : socket 'X'
        - y (Integer) : socket 'Y'
        - z (Integer) : socket 'Z'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'BOOLEAN', 'VECTOR')

        Returns
        -------
        - Float
        """
        node = Node('Sample Grid Index', {'Grid': grid, 'X': x, 'Y': y, 'Z': z}, data_type=data_type)
        return node._out


    @classmethod
    def sample_index(cls, geometry=None, value=None, index=None, clamp=False, data_type='FLOAT', domain='POINT'):
        """ > Node <&Node Sample Index>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - value (Float) : socket 'Value'
        - index (Integer) : socket 'Index'
        - clamp (bool): parameter 'clamp'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Float
        """
        node = Node('Sample Index', {'Geometry': geometry, 'Value': value, 'Index': index}, clamp=clamp, data_type=data_type, domain=domain)
        return node._out


    @classmethod
    def sample_nearest(cls, geometry=None, sample_position=None, domain='POINT'):
        """ > Node <&Node Sample Nearest>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - sample_position (Vector) : socket 'Sample Position'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER')

        Returns
        -------
        - Integer
        """
        node = Node('Sample Nearest', {'Geometry': geometry, 'Sample Position': sample_position}, domain=domain)
        return node._out


    @classmethod
    def sample_nearest_surface(cls, mesh=None, value=None, group_id=None, sample_position=None, sample_group_id=None, data_type='FLOAT'):
        """ > Node <&Node Sample Nearest Surface>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - value (Float) : socket 'Value'
        - group_id (Integer) : socket 'Group ID'
        - sample_position (Vector) : socket 'Sample Position'
        - sample_group_id (Integer) : socket 'Sample Group ID'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')

        Returns
        -------
        - Node : 'Sample Nearest Surface'
        """
        node = Node('Sample Nearest Surface', {'Mesh': mesh, 'Value': value, 'Group ID': group_id, 'Sample Position': sample_position, 'Sample Group ID': sample_group_id}, data_type=data_type)
        return node


    @classmethod
    def sample_uv_surface(cls, mesh=None, value=None, uv_map=None, sample_uv=None, data_type='FLOAT'):
        """ > Node <&Node Sample UV Surface>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - value (Float) : socket 'Value'
        - uv_map (Vector) : socket 'UV Map'
        - sample_uv (Vector) : socket 'Sample UV'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')

        Returns
        -------
        - Node : 'Sample UV Surface'
        """
        node = Node('Sample UV Surface', {'Mesh': mesh, 'Value': value, 'UV Map': uv_map, 'Sample UV': sample_uv}, data_type=data_type)
        return node


    @classmethod
    def scale_elements(cls, geometry=None, selection=None, scale=None, center=None, axis=None, domain='FACE', scale_mode='UNIFORM'):
        """ > Node <&Node Scale Elements>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - scale (Float) : socket 'Scale'
        - center (Vector) : socket 'Center'
        - axis (Vector) : socket 'Axis'
        - domain (str): parameter 'domain' in ('FACE', 'EDGE')
        - scale_mode (str): parameter 'scale_mode' in ('UNIFORM', 'SINGLE_AXIS')

        Returns
        -------
        - Geometry
        """
        node = Node('Scale Elements', {'Geometry': geometry, 'Selection': selection, 'Scale': scale, 'Center': center, 'Axis': axis}, domain=domain, scale_mode=scale_mode)
        return node._out


    @classmethod
    def scale_instances(cls, instances=None, selection=None, scale=None, center=None, local_space=None):
        """ > Node <&Node Scale Instances>

        Arguments
        ---------
        - instances (Geometry) : socket 'Instances'
        - selection (Boolean) : socket 'Selection'
        - scale (Vector) : socket 'Scale'
        - center (Vector) : socket 'Center'
        - local_space (Boolean) : socket 'Local Space'

        Returns
        -------
        - Geometry
        """
        node = Node('Scale Instances', {'Instances': instances, 'Selection': selection, 'Scale': scale, 'Center': center, 'Local Space': local_space})
        return node._out


    @classmethod
    @property
    def self_object(cls):
        """ > Node <&Node Self Object>

        Returns
        -------
        - Object
        """
        node = Node('Self Object')
        return node._out


    @classmethod
    def separate_components(cls, geometry=None):
        """ > Node <&Node Separate Components>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Node : 'Separate Components'
        """
        node = Node('Separate Components', {'Geometry': geometry})
        return node


    @classmethod
    def separate_geometry(cls, geometry=None, selection=None, domain='POINT'):
        """ > Node <&Node Separate Geometry>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Node : 'Separate Geometry'
        """
        node = Node('Separate Geometry', {'Geometry': geometry, 'Selection': selection}, domain=domain)
        return node


    @classmethod
    def set_handle_positions(cls, curve=None, selection=None, position=None, offset=None, mode='LEFT'):
        """ > Node <&Node Set Handle Positions>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - position (Vector) : socket 'Position'
        - offset (Vector) : socket 'Offset'
        - mode (str): parameter 'mode' in ('LEFT', 'RIGHT')

        Returns
        -------
        - Geometry
        """
        node = Node('Set Handle Positions', {'Curve': curve, 'Selection': selection, 'Position': position, 'Offset': offset}, mode=mode)
        return node._out


    @classmethod
    def set_curve_normal(cls, curve=None, selection=None, normal=None, mode='MINIMUM_TWIST'):
        """ > Node <&Node Set Curve Normal>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - normal (Vector) : socket 'Normal'
        - mode (str): parameter 'mode' in ('MINIMUM_TWIST', 'Z_UP', 'FREE')

        Returns
        -------
        - Geometry
        """
        node = Node('Set Curve Normal', {'Curve': curve, 'Selection': selection, 'Normal': normal}, mode=mode)
        return node._out


    @classmethod
    def set_curve_radius(cls, curve=None, selection=None, radius=None):
        """ > Node <&Node Set Curve Radius>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - radius (Float) : socket 'Radius'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Curve Radius', {'Curve': curve, 'Selection': selection, 'Radius': radius})
        return node._out


    @classmethod
    def set_curve_tilt(cls, curve=None, selection=None, tilt=None):
        """ > Node <&Node Set Curve Tilt>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - tilt (Float) : socket 'Tilt'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Curve Tilt', {'Curve': curve, 'Selection': selection, 'Tilt': tilt})
        return node._out


    @classmethod
    def set_geometry_name(cls, geometry=None, name=None):
        """ > Node <&Node Set Geometry Name>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - name (String) : socket 'Name'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Geometry Name', {'Geometry': geometry, 'Name': name})
        return node._out


    @classmethod
    def set_id(cls, geometry=None, selection=None, id=None):
        """ > Node <&Node Set ID>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - id (Integer) : socket 'ID'

        Returns
        -------
        - Geometry
        """
        node = Node('Set ID', {'Geometry': geometry, 'Selection': selection, 'ID': id})
        return node._out


    @classmethod
    def set_instance_transform(cls, instances=None, selection=None, transform=None):
        """ > Node <&Node Set Instance Transform>

        Arguments
        ---------
        - instances (Geometry) : socket 'Instances'
        - selection (Boolean) : socket 'Selection'
        - transform (Matrix) : socket 'Transform'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Instance Transform', {'Instances': instances, 'Selection': selection, 'Transform': transform})
        return node._out


    @classmethod
    def set_material(cls, geometry=None, selection=None, material=None):
        """ > Node <&Node Set Material>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - material (Material) : socket 'Material'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Material', {'Geometry': geometry, 'Selection': selection, 'Material': material})
        return node._out


    @classmethod
    def set_material_index(cls, geometry=None, selection=None, material_index=None):
        """ > Node <&Node Set Material Index>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - material_index (Integer) : socket 'Material Index'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Material Index', {'Geometry': geometry, 'Selection': selection, 'Material Index': material_index})
        return node._out


    @classmethod
    def set_point_radius(cls, points=None, selection=None, radius=None):
        """ > Node <&Node Set Point Radius>

        Arguments
        ---------
        - points (Geometry) : socket 'Points'
        - selection (Boolean) : socket 'Selection'
        - radius (Float) : socket 'Radius'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Point Radius', {'Points': points, 'Selection': selection, 'Radius': radius})
        return node._out


    @classmethod
    def set_position(cls, geometry=None, selection=None, position=None, offset=None):
        """ > Node <&Node Set Position>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - position (Vector) : socket 'Position'
        - offset (Vector) : socket 'Offset'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Position', {'Geometry': geometry, 'Selection': selection, 'Position': position, 'Offset': offset})
        return node._out


    @classmethod
    def set_shade_smooth(cls, geometry=None, selection=None, shade_smooth=None, domain='FACE'):
        """ > Node <&Node Set Shade Smooth>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - shade_smooth (Boolean) : socket 'Shade Smooth'
        - domain (str): parameter 'domain' in ('EDGE', 'FACE')

        Returns
        -------
        - Geometry
        """
        node = Node('Set Shade Smooth', {'Geometry': geometry, 'Selection': selection, 'Shade Smooth': shade_smooth}, domain=domain)
        return node._out


    @classmethod
    def set_spline_cyclic(cls, geometry=None, selection=None, cyclic=None):
        """ > Node <&Node Set Spline Cyclic>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - cyclic (Boolean) : socket 'Cyclic'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Spline Cyclic', {'Geometry': geometry, 'Selection': selection, 'Cyclic': cyclic})
        return node._out


    @classmethod
    def set_spline_resolution(cls, geometry=None, selection=None, resolution=None):
        """ > Node <&Node Set Spline Resolution>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - resolution (Integer) : socket 'Resolution'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Spline Resolution', {'Geometry': geometry, 'Selection': selection, 'Resolution': resolution})
        return node._out


    @classmethod
    def simulation_input(cls, pair_with_output=None, paired_output=None):
        """ > Node <&Node Simulation Input>

        Arguments
        ---------
        - pair_with_output (bpy_func): parameter 'pair_with_output'
        - paired_output (NoneType): parameter 'paired_output'

        Returns
        -------
        - Float
        """
        node = Node('Simulation Input', pair_with_output=pair_with_output, paired_output=paired_output)
        return node._out


    @classmethod
    def simulation_output(cls, _items={}, skip=None, geometry=None):
        """ > Node <&Node Simulation Output>

        Arguments
        ---------
        - items (dict) : items to create
        - skip (Boolean) : socket 'Skip'
        - geometry (Geometry) : socket 'Geometry'

        Returns
        -------
        - Node : 'Simulation Output'
        """
        node = Node('Simulation Output', {'Skip': skip, 'Geometry': geometry}, _items=_items)
        return node


    @classmethod
    def sort_elements(cls, geometry=None, selection=None, group_id=None, sort_weight=None, domain='POINT'):
        """ > Node <&Node Sort Elements>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - group_id (Integer) : socket 'Group ID'
        - sort_weight (Float) : socket 'Sort Weight'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CURVE', 'INSTANCE')

        Returns
        -------
        - Geometry
        """
        node = Node('Sort Elements', {'Geometry': geometry, 'Selection': selection, 'Group ID': group_id, 'Sort Weight': sort_weight}, domain=domain)
        return node._out


    @classmethod
    @property
    def spline_length(cls):
        """ > Node <&Node Spline Length>

        Returns
        -------
        - Node : 'Spline Length'
        """
        node = Node('Spline Length')
        return node


    @classmethod
    @property
    def spline_parameter(cls):
        """ > Node <&Node Spline Parameter>

        Returns
        -------
        - Node : 'Spline Parameter'
        """
        node = Node('Spline Parameter')
        return node


    @classmethod
    def split_edges(cls, mesh=None, selection=None):
        """ > Node <&Node Split Edges>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'

        Returns
        -------
        - Geometry
        """
        node = Node('Split Edges', {'Mesh': mesh, 'Selection': selection})
        return node._out


    @classmethod
    def split_to_instances(cls, geometry=None, selection=None, group_id=None, domain='POINT'):
        """ > Node <&Node Split to Instances>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - group_id (Integer) : socket 'Group ID'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Node : 'Split to Instances'
        """
        node = Node('Split to Instances', {'Geometry': geometry, 'Selection': selection, 'Group ID': group_id}, domain=domain)
        return node


    @classmethod
    def store_named_attribute(cls, geometry=None, selection=None, name=None, value=None, data_type='FLOAT', domain='POINT'):
        """ > Node <&Node Store Named Attribute>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - name (String) : socket 'Name'
        - value (Float) : socket 'Value'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BYTE_COLOR', 'BOOLEAN', 'FLOAT2', 'INT8', 'QUATERNION', 'FLOAT4X4')
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Geometry
        """
        node = Node('Store Named Attribute', {'Geometry': geometry, 'Selection': selection, 'Name': name, 'Value': value}, data_type=data_type, domain=domain)
        return node._out


    @classmethod
    def store_named_grid(cls, volume=None, name=None, grid=None, data_type='FLOAT'):
        """ > Node <&Node Store Named Grid>

        Arguments
        ---------
        - volume (Geometry) : socket 'Volume'
        - name (String) : socket 'Name'
        - grid (Float) : socket 'Grid'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'FLOAT_VECTOR', 'FLOAT2')

        Returns
        -------
        - Geometry
        """
        node = Node('Store Named Grid', {'Volume': volume, 'Name': name, 'Grid': grid}, data_type=data_type)
        return node._out


    @classmethod
    def join_strings(cls, delimiter=None, strings=None):
        """ > Node <&Node Join Strings>

        Arguments
        ---------
        - delimiter (String) : socket 'Delimiter'
        - strings (String) : socket 'Strings'

        Returns
        -------
        - String
        """
        node = Node('Join Strings', {'Delimiter': delimiter, 'Strings': strings})
        return node._out


    @classmethod
    def string_to_curves(cls, string=None, size=None, character_spacing=None, word_spacing=None, line_spacing=None, text_box_width=None, text_box_height=None, align_x='LEFT', align_y='TOP_BASELINE', font=None, overflow='OVERFLOW', pivot_mode='BOTTOM_LEFT'):
        """ > Node <&Node String to Curves>

        Arguments
        ---------
        - string (String) : socket 'String'
        - size (Float) : socket 'Size'
        - character_spacing (Float) : socket 'Character Spacing'
        - word_spacing (Float) : socket 'Word Spacing'
        - line_spacing (Float) : socket 'Line Spacing'
        - text_box_width (Float) : socket 'Text Box Width'
        - text_box_height (Float) : socket 'Text Box Height'
        - align_x (str): parameter 'align_x' in ('LEFT', 'CENTER', 'RIGHT', 'JUSTIFY', 'FLUSH')
        - align_y (str): parameter 'align_y' in ('TOP', 'TOP_BASELINE', 'MIDDLE', 'BOTTOM_BASELINE', 'BOTTOM')
        - font (VectorFont): parameter 'font'
        - overflow (str): parameter 'overflow' in ('OVERFLOW', 'SCALE_TO_FIT', 'TRUNCATE')
        - pivot_mode (str): parameter 'pivot_mode' in ('MIDPOINT', 'TOP_LEFT', 'TOP_CENTER', 'TOP_RIGHT', 'BOTTOM_LEFT', 'BOTTOM_CENTER', 'BOTTOM_RIGHT')

        Returns
        -------
        - Node : 'String to Curves'
        """
        node = Node('String to Curves', {'String': string, 'Size': size, 'Character Spacing': character_spacing, 'Word Spacing': word_spacing, 'Line Spacing': line_spacing, 'Text Box Width': text_box_width, 'Text Box Height': text_box_height}, align_x=align_x, align_y=align_y, font=font, overflow=overflow, pivot_mode=pivot_mode)
        return node


    @classmethod
    def subdivide_curve(cls, curve=None, cuts=None):
        """ > Node <&Node Subdivide Curve>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - cuts (Integer) : socket 'Cuts'

        Returns
        -------
        - Geometry
        """
        node = Node('Subdivide Curve', {'Curve': curve, 'Cuts': cuts})
        return node._out


    @classmethod
    def subdivide_mesh(cls, mesh=None, level=None):
        """ > Node <&Node Subdivide Mesh>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - level (Integer) : socket 'Level'

        Returns
        -------
        - Geometry
        """
        node = Node('Subdivide Mesh', {'Mesh': mesh, 'Level': level})
        return node._out


    @classmethod
    def subdivision_surface(cls, mesh=None, level=None, edge_crease=None, vertex_crease=None, boundary_smooth='ALL', uv_smooth='PRESERVE_BOUNDARIES'):
        """ > Node <&Node Subdivision Surface>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - level (Integer) : socket 'Level'
        - edge_crease (Float) : socket 'Edge Crease'
        - vertex_crease (Float) : socket 'Vertex Crease'
        - boundary_smooth (str): parameter 'boundary_smooth' in ('PRESERVE_CORNERS', 'ALL')
        - uv_smooth (str): parameter 'uv_smooth' in ('NONE', 'PRESERVE_CORNERS', 'PRESERVE_CORNERS_AND_JUNCTIONS', 'PRESERVE_CORNERS_JUNCTIONS_AND_CONCAVE', 'PRESERVE_BOUNDARIES', 'SMOOTH_ALL')

        Returns
        -------
        - Geometry
        """
        node = Node('Subdivision Surface', {'Mesh': mesh, 'Level': level, 'Edge Crease': edge_crease, 'Vertex Crease': vertex_crease}, boundary_smooth=boundary_smooth, uv_smooth=uv_smooth)
        return node._out


    @classmethod
    def switch(cls, switch=None, false=None, true=None, input_type='GEOMETRY'):
        """ > Node <&Node Switch>

        Arguments
        ---------
        - switch (Boolean) : socket 'Switch'
        - false (Geometry) : socket 'False'
        - true (Geometry) : socket 'True'
        - input_type (str): parameter 'input_type' in ('FLOAT', 'INT', 'BOOLEAN', 'VECTOR', 'ROTATION', 'MATRIX', 'STRING', 'MENU', 'RGBA', 'OBJECT', 'IMAGE', 'GEOMETRY', 'COLLECTION', 'MATERIAL')

        Returns
        -------
        - Geometry
        """
        node = Node('Switch', {'Switch': switch, 'False': false, 'True': true}, input_type=input_type)
        return node._out


    @classmethod
    @property
    def _3d_cursor(cls):
        """ > Node <&Node 3D Cursor>

        Returns
        -------
        - Node : '3D Cursor'
        """
        node = Node('3D Cursor')
        return node


    @classmethod
    def active_element(cls, domain='POINT'):
        """ > Node <&Node Active Element>

        Arguments
        ---------
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE')

        Returns
        -------
        - Node : 'Active Element'
        """
        node = Node('Active Element', domain=domain)
        return node


    @classmethod
    @property
    def face_set(cls):
        """ > Node <&Node Face Set>

        Returns
        -------
        - Node : 'Face Set'
        """
        node = Node('Face Set')
        return node


    @classmethod
    @property
    def mouse_position(cls):
        """ > Node <&Node Mouse Position>

        Returns
        -------
        - Node : 'Mouse Position'
        """
        node = Node('Mouse Position')
        return node


    @classmethod
    @property
    def selection(cls):
        """ > Node <&Node Selection>

        Returns
        -------
        - Node : 'Selection'
        """
        node = Node('Selection')
        return node


    @classmethod
    def set_face_set(cls, mesh=None, selection=None, face_set=None):
        """ > Node <&Node Set Face Set>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'
        - face_set (Integer) : socket 'Face Set'

        Returns
        -------
        - Geometry
        """
        node = Node('Set Face Set', {'Mesh': mesh, 'Selection': selection, 'Face Set': face_set})
        return node._out


    @classmethod
    def set_selection(cls, geometry=None, selection=None, domain='POINT', selection_type='BOOLEAN'):
        """ > Node <&Node Set Selection>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - selection (Boolean) : socket 'Selection'
        - domain (str): parameter 'domain' in ('POINT', 'EDGE', 'FACE', 'CURVE')
        - selection_type (str): parameter 'selection_type' in ('BOOLEAN', 'FLOAT')

        Returns
        -------
        - Geometry
        """
        node = Node('Set Selection', {'Geometry': geometry, 'Selection': selection}, domain=domain, selection_type=selection_type)
        return node._out


    @classmethod
    def transform_geometry(cls, geometry=None, translation=None, rotation=None, scale=None, transform=None, mode='COMPONENTS'):
        """ > Node <&Node Transform Geometry>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - translation (Vector) : socket 'Translation'
        - rotation (Rotation) : socket 'Rotation'
        - scale (Vector) : socket 'Scale'
        - transform (Matrix) : socket 'Transform'
        - mode (str): parameter 'mode' in ('COMPONENTS', 'MATRIX')

        Returns
        -------
        - Geometry
        """
        node = Node('Transform Geometry', {'Geometry': geometry, 'Translation': translation, 'Rotation': rotation, 'Scale': scale, 'Transform': transform}, mode=mode)
        return node._out


    @classmethod
    def translate_instances(cls, instances=None, selection=None, translation=None, local_space=None):
        """ > Node <&Node Translate Instances>

        Arguments
        ---------
        - instances (Geometry) : socket 'Instances'
        - selection (Boolean) : socket 'Selection'
        - translation (Vector) : socket 'Translation'
        - local_space (Boolean) : socket 'Local Space'

        Returns
        -------
        - Geometry
        """
        node = Node('Translate Instances', {'Instances': instances, 'Selection': selection, 'Translation': translation, 'Local Space': local_space})
        return node._out


    @classmethod
    def triangulate(cls, mesh=None, selection=None, minimum_vertices=None, ngon_method='BEAUTY', quad_method='SHORTEST_DIAGONAL'):
        """ > Node <&Node Triangulate>

        Arguments
        ---------
        - mesh (Geometry) : socket 'Mesh'
        - selection (Boolean) : socket 'Selection'
        - minimum_vertices (Integer) : socket 'Minimum Vertices'
        - ngon_method (str): parameter 'ngon_method' in ('BEAUTY', 'CLIP')
        - quad_method (str): parameter 'quad_method' in ('BEAUTY', 'FIXED', 'FIXED_ALTERNATE', 'SHORTEST_DIAGONAL', 'LONGEST_DIAGONAL')

        Returns
        -------
        - Geometry
        """
        node = Node('Triangulate', {'Mesh': mesh, 'Selection': selection, 'Minimum Vertices': minimum_vertices}, ngon_method=ngon_method, quad_method=quad_method)
        return node._out


    @classmethod
    def trim_curve(cls, curve=None, selection=None, start=None, end=None, mode='FACTOR'):
        """ > Node <&Node Trim Curve>

        Arguments
        ---------
        - curve (Geometry) : socket 'Curve'
        - selection (Boolean) : socket 'Selection'
        - start (Float) : socket 'Start'
        - end (Float) : socket 'End'
        - mode (str): parameter 'mode' in ('FACTOR', 'LENGTH')

        Returns
        -------
        - Geometry
        """
        node = Node('Trim Curve', {'Curve': curve, 'Selection': selection, 'Start': start, 'End': end}, mode=mode)
        return node._out


    @classmethod
    def pack_uv_islands(cls, uv=None, selection=None, margin=None, rotate=None):
        """ > Node <&Node Pack UV Islands>

        Arguments
        ---------
        - uv (Vector) : socket 'UV'
        - selection (Boolean) : socket 'Selection'
        - margin (Float) : socket 'Margin'
        - rotate (Boolean) : socket 'Rotate'

        Returns
        -------
        - Vector
        """
        node = Node('Pack UV Islands', {'UV': uv, 'Selection': selection, 'Margin': margin, 'Rotate': rotate})
        return node._out


    @classmethod
    def uv_unwrap(cls, selection=None, seam=None, margin=None, fill_holes=None, method='ANGLE_BASED'):
        """ > Node <&Node UV Unwrap>

        Arguments
        ---------
        - selection (Boolean) : socket 'Selection'
        - seam (Boolean) : socket 'Seam'
        - margin (Float) : socket 'Margin'
        - fill_holes (Boolean) : socket 'Fill Holes'
        - method (str): parameter 'method' in ('ANGLE_BASED', 'CONFORMAL')

        Returns
        -------
        - Vector
        """
        node = Node('UV Unwrap', {'Selection': selection, 'Seam': seam, 'Margin': margin, 'Fill Holes': fill_holes}, method=method)
        return node._out


    @classmethod
    def vertex_of_corner(cls, corner_index=None):
        """ > Node <&Node Vertex of Corner>

        Arguments
        ---------
        - corner_index (Integer) : socket 'Corner Index'

        Returns
        -------
        - Integer
        """
        node = Node('Vertex of Corner', {'Corner Index': corner_index})
        return node._out


    @classmethod
    def viewer(cls, geometry=None, value=None, data_type='FLOAT', domain='AUTO'):
        """ > Node <&Node Viewer>

        Arguments
        ---------
        - geometry (Geometry) : socket 'Geometry'
        - value (Float) : socket 'Value'
        - data_type (str): parameter 'data_type' in ('FLOAT', 'INT', 'FLOAT_VECTOR', 'FLOAT_COLOR', 'BOOLEAN', 'QUATERNION', 'FLOAT4X4')
        - domain (str): parameter 'domain' in ('AUTO', 'POINT', 'EDGE', 'FACE', 'CORNER', 'CURVE', 'INSTANCE', 'LAYER')

        Returns
        -------
        - Node : 'Viewer'
        """
        node = Node('Viewer', {'Geometry': geometry, 'Value': value}, data_type=data_type, domain=domain)
        return node


    @classmethod
    @property
    def viewport_transform(cls):
        """ > Node <&Node Viewport Transform>

        Returns
        -------
        - Node : 'Viewport Transform'
        """
        node = Node('Viewport Transform')
        return node


    @classmethod
    def volume_cube(cls, density=None, background=None, min=None, max=None, resolution_x=None, resolution_y=None, resolution_z=None):
        """ > Node <&Node Volume Cube>

        Arguments
        ---------
        - density (Float) : socket 'Density'
        - background (Float) : socket 'Background'
        - min (Vector) : socket 'Min'
        - max (Vector) : socket 'Max'
        - resolution_x (Integer) : socket 'Resolution X'
        - resolution_y (Integer) : socket 'Resolution Y'
        - resolution_z (Integer) : socket 'Resolution Z'

        Returns
        -------
        - Geometry
        """
        node = Node('Volume Cube', {'Density': density, 'Background': background, 'Min': min, 'Max': max, 'Resolution X': resolution_x, 'Resolution Y': resolution_y, 'Resolution Z': resolution_z})
        return node._out


    @classmethod
    def volume_to_mesh(cls, volume=None, voxel_size=None, voxel_amount=None, threshold=None, adaptivity=None, resolution_mode='GRID'):
        """ > Node <&Node Volume to Mesh>

        Arguments
        ---------
        - volume (Geometry) : socket 'Volume'
        - voxel_size (Float) : socket 'Voxel Size'
        - voxel_amount (Float) : socket 'Voxel Amount'
        - threshold (Float) : socket 'Threshold'
        - adaptivity (Float) : socket 'Adaptivity'
        - resolution_mode (str): parameter 'resolution_mode' in ('GRID', 'VOXEL_AMOUNT', 'VOXEL_SIZE')

        Returns
        -------
        - Geometry
        """
        node = Node('Volume to Mesh', {'Volume': volume, 'Voxel Size': voxel_size, 'Voxel Amount': voxel_amount, 'Threshold': threshold, 'Adaptivity': adaptivity}, resolution_mode=resolution_mode)
        return node._out


    @classmethod
    def warning(cls, show=None, message=None, warning_type='ERROR'):
        """ > Node <&Node Warning>

        Arguments
        ---------
        - show (Boolean) : socket 'Show'
        - message (String) : socket 'Message'
        - warning_type (str): parameter 'warning_type'

        Returns
        -------
        - Boolean
        """
        node = Node('Warning', {'Show': show, 'Message': message}, warning_type=warning_type)
        return node._out


    @classmethod
    def _receipt_modifier(cls):
        from geonodes import GeoNodes, ShaderNodes, nd, snd
        with GeoNodes('receipt_modifier'):
            nd.align_rotation_to_vector()
            nd.axes_to_rotation()
            nd.axis_angle_to_rotation()
            nd.boolean_math()
            nd.combine_color()
            nd.combine_matrix()
            nd.combine_transform()
            nd.compare()
            nd.euler_to_rotation()
            nd.float_to_integer()
            nd.hash_value()
            nd.boolean()
            nd.color()
            nd.integer()
            nd.rotation()
            nd.special_characters
            nd.string()
            nd.vector()
            nd.integer_math()
            nd.invert_matrix()
            nd.invert_rotation()
            nd.matrix_determinant()
            nd.multiply_matrices()
            nd.project_point()
            nd.quaternion_to_rotation()
            nd.random_value()
            nd.replace_string()
            nd.rotate_rotation()
            nd.rotate_vector()
            nd.rotation_to_axis_angle()
            nd.rotation_to_euler()
            nd.rotation_to_quaternion()
            nd.separate_color()
            nd.separate_matrix()
            nd.separate_transform()
            nd.slice_string()
            nd.string_length()
            nd.transform_direction()
            nd.transform_point()
            nd.transpose_matrix()
            nd.value_to_string()
            nd.accumulate_field()
            nd.domain_size()
            nd.attribute_statistic()
            nd.bake()
            nd.blur_attribute()
            nd.bounding_box()
            nd.capture_attribute()
            nd.collection_info()
            nd.convex_hull()
            nd.corners_of_edge()
            nd.corners_of_face()
            nd.corners_of_vertex()
            nd.arc()
            nd.endpoint_selection()
            nd.handle_type_selection()
            nd.curve_length()
            nd.curve_of_point()
            nd.bezier_segment()
            nd.curve_circle()
            nd.curve_line()
            nd.quadrilateral()
            nd.quadratic_bezier()
            nd.set_handle_type()
            nd.spiral()
            nd.set_spline_type()
            nd.star()
            nd.curve_to_mesh()
            nd.curve_to_points()
            nd.curves_to_grease_pencil()
            nd.deform_curves_on_surface()
            nd.delete_geometry()
            nd.distribute_points_in_grid()
            nd.distribute_points_in_volume()
            nd.distribute_points_on_faces()
            nd.dual_mesh()
            nd.duplicate_elements()
            nd.edge_paths_to_curves()
            nd.edge_paths_to_selection()
            nd.edges_of_corner()
            nd.edges_of_vertex()
            nd.edges_to_face_groups()
            nd.extrude_mesh()
            nd.face_of_corner()
            nd.evaluate_at_index()
            nd.evaluate_on_domain()
            nd.fill_curve()
            nd.fillet_curve()
            nd.flip_faces()
            nd.for_each_geometry_element_input()
            nd.for_each_geometry_element_output()
            nd.geometry_to_instance()
            nd.get_named_grid()
            nd.dial_gizmo()
            nd.linear_gizmo()
            nd.transform_gizmo()
            nd.grease_pencil_to_curves()
            nd.grid_to_mesh()
            nd.group()
            nd.image_info()
            nd.image_texture()
            nd.import_obj()
            nd.import_ply()
            nd.import_stl()
            nd.index_of_nearest()
            nd.index_switch()
            nd.active_camera
            nd.curve_handle_positions()
            nd.curve_tilt
            nd.is_edge_smooth
            nd.id
            nd.image()
            nd.index
            nd.instance_rotation
            nd.instance_scale
            nd.material()
            nd.material_index
            nd.edge_angle
            nd.edge_neighbors
            nd.edge_vertices
            nd.face_area
            nd.is_face_planar()
            nd.face_neighbors
            nd.mesh_island
            nd.vertex_neighbors
            nd.named_attribute()
            nd.named_layer_selection()
            nd.normal
            nd.position
            nd.radius
            nd.scene_time
            nd.is_face_smooth
            nd.shortest_edge_paths()
            nd.is_spline_cyclic
            nd.spline_resolution
            nd.curve_tangent
            nd.instance_on_points()
            nd.instance_transform
            nd.instances_to_points()
            nd.interpolate_curves()
            nd.is_viewport
            nd.join_geometry()
            nd.material_selection()
            nd.menu_switch()
            nd.merge_by_distance()
            nd.merge_layers()
            nd.mesh_boolean()
            nd.mesh_circle()
            nd.cone()
            nd.cube()
            nd.cylinder()
            nd.face_group_boundaries()
            nd.grid()
            nd.ico_sphere()
            nd.mesh_line()
            nd.mesh_to_curve()
            nd.mesh_to_density_grid()
            nd.mesh_to_points()
            nd.mesh_to_sdf_grid()
            nd.mesh_to_volume()
            nd.uv_sphere()
            nd.object_info()
            nd.offset_corner_in_face()
            nd.offset_point_in_curve()
            nd.points()
            nd.points_of_curve()
            nd.points_to_curves()
            nd.points_to_sdf_grid()
            nd.points_to_vertices()
            nd.points_to_volume()
            nd.geometry_proximity()
            nd.raycast()
            nd.realize_instances()
            nd.remove_named_attribute()
            nd.repeat_input()
            nd.repeat_output()
            nd.replace_material()
            nd.resample_curve()
            nd.reverse_curve()
            nd.rotate_instances()
            nd.sdf_grid_boolean()
            nd.sample_curve()
            nd.sample_grid()
            nd.sample_grid_index()
            nd.sample_index()
            nd.sample_nearest()
            nd.sample_nearest_surface()
            nd.sample_uv_surface()
            nd.scale_elements()
            nd.scale_instances()
            nd.self_object
            nd.separate_components()
            nd.separate_geometry()
            nd.set_handle_positions()
            nd.set_curve_normal()
            nd.set_curve_radius()
            nd.set_curve_tilt()
            nd.set_geometry_name()
            nd.set_id()
            nd.set_instance_transform()
            nd.set_material()
            nd.set_material_index()
            nd.set_point_radius()
            nd.set_position()
            nd.set_shade_smooth()
            nd.set_spline_cyclic()
            nd.set_spline_resolution()
            nd.simulation_input()
            nd.simulation_output()
            nd.sort_elements()
            nd.spline_length
            nd.spline_parameter
            nd.split_edges()
            nd.split_to_instances()
            nd.store_named_attribute()
            nd.store_named_grid()
            nd.join_strings()
            nd.string_to_curves()
            nd.subdivide_curve()
            nd.subdivide_mesh()
            nd.subdivision_surface()
            nd.switch()
            nd.transform_geometry()
            nd.translate_instances()
            nd.triangulate()
            nd.trim_curve()
            nd.pack_uv_islands()
            nd.uv_unwrap()
            nd.vertex_of_corner()
            nd.viewer()
            nd.volume_cube()
            nd.volume_to_mesh()
            nd.warning()

    @classmethod
    def _receipt_tool(cls):
        from geonodes import GeoNodes, ShaderNodes, nd, snd
        with GeoNodes.Tool('receipt_tool'):
            nd.align_rotation_to_vector()
            nd.axes_to_rotation()
            nd.axis_angle_to_rotation()
            nd.boolean_math()
            nd.combine_color()
            nd.combine_matrix()
            nd.combine_transform()
            nd.compare()
            nd.euler_to_rotation()
            nd.float_to_integer()
            nd.hash_value()
            nd.boolean()
            nd.color()
            nd.integer()
            nd.rotation()
            nd.special_characters
            nd.string()
            nd.vector()
            nd.integer_math()
            nd.invert_matrix()
            nd.invert_rotation()
            nd.matrix_determinant()
            nd.multiply_matrices()
            nd.project_point()
            nd.quaternion_to_rotation()
            nd.random_value()
            nd.replace_string()
            nd.rotate_rotation()
            nd.rotate_vector()
            nd.rotation_to_axis_angle()
            nd.rotation_to_euler()
            nd.rotation_to_quaternion()
            nd.separate_color()
            nd.separate_matrix()
            nd.separate_transform()
            nd.slice_string()
            nd.string_length()
            nd.transform_direction()
            nd.transform_point()
            nd.transpose_matrix()
            nd.value_to_string()
            nd.accumulate_field()
            nd.domain_size()
            nd.attribute_statistic()
            nd.bake()
            nd.blur_attribute()
            nd.bounding_box()
            nd.capture_attribute()
            nd.collection_info()
            nd.convex_hull()
            nd.corners_of_edge()
            nd.corners_of_face()
            nd.corners_of_vertex()
            nd.arc()
            nd.endpoint_selection()
            nd.handle_type_selection()
            nd.curve_length()
            nd.curve_of_point()
            nd.bezier_segment()
            nd.curve_circle()
            nd.curve_line()
            nd.quadrilateral()
            nd.quadratic_bezier()
            nd.set_handle_type()
            nd.spiral()
            nd.set_spline_type()
            nd.star()
            nd.curve_to_mesh()
            nd.curve_to_points()
            nd.curves_to_grease_pencil()
            nd.deform_curves_on_surface()
            nd.delete_geometry()
            nd.distribute_points_in_grid()
            nd.distribute_points_in_volume()
            nd.distribute_points_on_faces()
            nd.dual_mesh()
            nd.duplicate_elements()
            nd.edge_paths_to_curves()
            nd.edge_paths_to_selection()
            nd.edges_of_corner()
            nd.edges_of_vertex()
            nd.edges_to_face_groups()
            nd.extrude_mesh()
            nd.face_of_corner()
            nd.evaluate_at_index()
            nd.evaluate_on_domain()
            nd.fill_curve()
            nd.fillet_curve()
            nd.flip_faces()
            nd.for_each_geometry_element_input()
            nd.for_each_geometry_element_output()
            nd.geometry_to_instance()
            nd.get_named_grid()
            nd.dial_gizmo()
            nd.linear_gizmo()
            nd.transform_gizmo()
            nd.grease_pencil_to_curves()
            nd.grid_to_mesh()
            nd.group()
            nd.image_info()
            nd.image_texture()
            nd.import_obj()
            nd.import_ply()
            nd.import_stl()
            nd.index_of_nearest()
            nd.index_switch()
            nd.active_camera
            nd.curve_handle_positions()
            nd.curve_tilt
            nd.is_edge_smooth
            nd.id
            nd.image()
            nd.index
            nd.instance_rotation
            nd.instance_scale
            nd.material()
            nd.material_index
            nd.edge_angle
            nd.edge_neighbors
            nd.edge_vertices
            nd.face_area
            nd.is_face_planar()
            nd.face_neighbors
            nd.mesh_island
            nd.vertex_neighbors
            nd.named_attribute()
            nd.named_layer_selection()
            nd.normal
            nd.position
            nd.radius
            nd.scene_time
            nd.is_face_smooth
            nd.shortest_edge_paths()
            nd.is_spline_cyclic
            nd.spline_resolution
            nd.curve_tangent
            nd.instance_on_points()
            nd.instance_transform
            nd.instances_to_points()
            nd.interpolate_curves()
            nd.is_viewport
            nd.join_geometry()
            nd.material_selection()
            nd.menu_switch()
            nd.merge_by_distance()
            nd.merge_layers()
            nd.mesh_boolean()
            nd.mesh_circle()
            nd.cone()
            nd.cube()
            nd.cylinder()
            nd.face_group_boundaries()
            nd.grid()
            nd.ico_sphere()
            nd.mesh_line()
            nd.mesh_to_curve()
            nd.mesh_to_density_grid()
            nd.mesh_to_points()
            nd.mesh_to_sdf_grid()
            nd.mesh_to_volume()
            nd.uv_sphere()
            nd.object_info()
            nd.offset_corner_in_face()
            nd.offset_point_in_curve()
            nd.points()
            nd.points_of_curve()
            nd.points_to_curves()
            nd.points_to_sdf_grid()
            nd.points_to_vertices()
            nd.points_to_volume()
            nd.geometry_proximity()
            nd.raycast()
            nd.realize_instances()
            nd.remove_named_attribute()
            nd.repeat_input()
            nd.repeat_output()
            nd.replace_material()
            nd.resample_curve()
            nd.reverse_curve()
            nd.rotate_instances()
            nd.sdf_grid_boolean()
            nd.sample_curve()
            nd.sample_grid()
            nd.sample_grid_index()
            nd.sample_index()
            nd.sample_nearest()
            nd.sample_nearest_surface()
            nd.sample_uv_surface()
            nd.scale_elements()
            nd.scale_instances()
            nd.self_object
            nd.separate_components()
            nd.separate_geometry()
            nd.set_handle_positions()
            nd.set_curve_normal()
            nd.set_curve_radius()
            nd.set_curve_tilt()
            nd.set_geometry_name()
            nd.set_id()
            nd.set_instance_transform()
            nd.set_material()
            nd.set_material_index()
            nd.set_point_radius()
            nd.set_position()
            nd.set_shade_smooth()
            nd.set_spline_cyclic()
            nd.set_spline_resolution()
            nd.simulation_output()
            nd.sort_elements()
            nd.spline_length
            nd.spline_parameter
            nd.split_edges()
            nd.split_to_instances()
            nd.store_named_attribute()
            nd.store_named_grid()
            nd.join_strings()
            nd.string_to_curves()
            nd.subdivide_curve()
            nd.subdivide_mesh()
            nd.subdivision_surface()
            nd.switch()
            nd._3d_cursor
            nd.active_element()
            nd.face_set
            nd.mouse_position
            nd.selection
            nd.set_face_set()
            nd.set_selection()
            nd.transform_geometry()
            nd.translate_instances()
            nd.triangulate()
            nd.trim_curve()
            nd.pack_uv_islands()
            nd.uv_unwrap()
            nd.vertex_of_corner()
            nd.viewport_transform
            nd.volume_cube()
            nd.volume_to_mesh()
            nd.warning()
