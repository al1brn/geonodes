#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May 29 12:31:31 2022

@author: alain

Generate geonodes Blender addon

====================================================================================================
Description

The geonodes implements two layers:
    - Nodes layer
        One class per geometry nodes, for instance AlignEulerToVector wraps the node FunctionNodeAlignEulerToVector
        The Node class initialization creates the geometry nodes
    - Sockets layer
        One class per data type:
            Basis data: Boolean, Integer, Float, Vector, Color, String
            Geometry  : Geometry, Spline, Curve, Mesh, Point, Instance, Volume
            Special   : Collection, Object, Material, Texture, Image
        The methods and properties of the sockets are implemented by creating nodes:
            circle = Mesh.Circle(radius=2.) --> creates the node GeometryNodeMeshCircle
            
A node accepts data sockets as inputs and return data sockets as ouputs
In addition, it can take parameters

====================================================================================================
Use

In a Blender project, create a Geometry nodes modifier and run the following script

from generator.generator import gen_geonodes

gen_geonodes(fpath)

where fpath is the folder into which generating the files


====================================================================================================
geonodes is made of following structure

----------------------------------------------------------------------------------------------------
----- geonodes.core

----- geonodes.core.node

Tree        : Blender NodeTree wrapper
DataSocket  : Root class for socket wrappers
Node        : Root class for blender geometry nodes wrappers

Some specific nodes are implemented in this module
They are used by Tree:
    
NodeGroup   : Root for GroupInput and GroupOutput

GroupInput  : Wrapper for node NodeGroupInput
              property: tree.group_input
              
GroupOutput : Wrapper for node NodeGroupOutput
              property: tree.group_output
              
Viewer      : Wrapper for node GeometryNodeViewer
              One viewer per tree. Data sockets can use the method to_viewer()
              
Frame       : Wrapper for node NodeFrame
              Tree implemenents new_layout() and close_layout() using Frame

SceneTime   : Wrapper for GeometryNodeInputSceneTime        


----- geonodes.core.datasockets

Implements the base class for DataSockets
All the classes are base on geonode.node.DataSocket

For geometry data, only the class Geometry is implemented in this module
The final classes will be created in geonodes.sockets with the following inheritance

Geometry
    - Spline
        - Curve
    - Mesh
        - Points
        - Instance
        - Volume
        
----- geonodes.core.colors

Some colors constants

----- geonodes.core.arrange

arrange function locates the nodes to make the whole tree somehow readable
It works independantly of the geonodes structure and just take the name
of the NodeTree as an argument.

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.nodes

All he nodes generated by the generator

----------------------------------------------------------------------------------------------------
----- geonodes.nodes.sockets

One file per data socket class plus functions.py which contains the global functions

----------------------------------------------------------------------------------------------------
----- geonodes.__init__.py

The pack initi file contains

====================================================================================================

Generation principle

The generation module is designed to ease the updates with the new versions of geometry nodes

Step 1
------
    try to create all the possible nodes by listing all the types in bpy.types:
    
    for type_name in dir(bpy.types):
        try:
            node = nodes.new(type_name)
        except:
            continue
        
        # We have a valid type
        
    The legacy nodes are excluded from the scane
    
Step 2
------
    Each node is analyzed by:
        - Identifying the parameters (non standard attributes)
            Three types of parameters are possible:
                - Non settable parameters, for instance the color selector of an input color node
                - Enum parameters: str param with a list of valid values
                - Non enum settable parameters, the resolution of a circle for instance
            The settable parameters will be part of the node creation argument
        
        - Identifying if the node has "shared sockets"
            Shared sockets are sockets of different types but sharing the same name.
            Only one socket is enabled at a time, depending upon a "driving parameter"
            Example: node FunctionNodeCompare:
                    - Driving parameter : data_type in ('FLOAT', 'INT', 'VECTOR', 'STRING', 'RGBA')
                    - Input sockets     : ['a', 'b']
                    a and b are names shared by sockets of type Float, Integer, Vector, String and Color
                    
        - Renaming sockets homonyms when exist
            For instance node ShaderNodeMath has three input sockets named Value. They are renamed
            value0, value1 and value2
                    
Step 3
------
    file nodes.py generation in folder geonodes.nodes
    
    The __init__ method of the node class is the concatenation of the input sockets and the settable parameters
    
    for instance, the __init__ method of ShaderNodeMath is:
        
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD'):
            
            The node has 3 sockets and one parameter named operation.
            The default value 'ADD' is the one of the parameter at creation time.
            When a socket has the value None, it is left unplugged.
            A socket can be either a value or data socket class. If it is a value, it
            must be an acceptable default value for the input socket.
            
    An additional argument label is used to allow the user to change the node label:
        def __init__(self, value0=None, value1=None, value2=None, operation='ADD', label=None):
            
Step 4
------
    Generation of the data sockets classes.
    
    A data socket basically wraps an output node socket.
    The methods of a data class consist in creating a node and to plug the socket to one
    input socket of this node.
    
    Example:
        Let use x as a Float which is the output socket of a node.
        We can write:
            
            y = x ** 3
            
        This will create the node ShaderNodeMath with the following parameters:
            
            node = Math(value0=self, value1=3, operation='POWER')
            return node.value
        
    Implementation types
    ---------------------
    
    Depending on their behaviors, the nodes can be implented in the following ways:
        
        Constructor
        -----------
            For nodes which don't transform a socket but create new data
            
            Example: GeometryNodeMeshCircle is implemented as a Mesh constructor
            
            @classmethod
            def Circle(cls, vertices=None, radius=None, fill_type='NONE'):
                return cls(nodes.MeshCircle(vertices=vertices, radius=radius, fill_type=fill_type).mesh)
            
        Property
        --------
            For node which return info on data sockets. The properties are kept in local attributes:
                
                self.prop_ = ... node creation
                return self.prop_
            
            Example: GeometryNodeBoundBox returns 3 infos on the geometry : bounding_box, min and max


"""

import bpy
import mathutils
from pprint import pprint, pformat

import logging
logger = logging.getLogger('geonodes')
logger.setLevel(logging.INFO)

from generator import gen_sockets as gsock

import importlib
importlib.reload(gsock)

# ====================================================================================================
# Some nodes need to reorder the input sockets for more natural use
# Example : the input sockets node ShaderNodeMixRGB are order fac, color1, color2
#           by reordering color1, color2, fac allows to call color.mix(color_argument)
#           rather than color.mix(color2=color_argument)

INPUT_SOCKETS_ORDER = {
    'ShaderNodeMixRGB' : {'Fac': 2, 'Color1': 0, 'Color2': 1},
}

# ====================================================================================================
# Utility

def indent_set(depth=0):
    _indent_ = "    "
    _0_ = "\n" + _indent_ * max(0, 0 + depth)
    _1_ = "\n" + _indent_ * max(0, 1 + depth)
    _2_ = "\n" + _indent_ * max(0, 2 + depth)
    _3_ = "\n" + _indent_ * max(0, 3 + depth)
    _4_ = "\n" + _indent_ * max(0, 4 + depth)
    
    return _indent_, _0_, _1_, _2_, _3_, _4_

_indent_, _0_, _1_, _2_, _3_, _4_ = indent_set(0)

# ====================================================================================================
# All nodes

btree_nodes = bpy.data.node_groups["Geometry Nodes"].nodes
btree_nodes.clear()

class BNodes(dict):
    def __init__(self):
        super().__init__()
        for tp in dir(bpy.types):
            if tp.find('Legacy') < 0:
                try:
                    bnode = btree_nodes.new(tp)
                except:
                    continue
                self[tp] = bnode
                
BNODES = BNodes()

# ====================================================================================================
# Call argument
#
# Argument types:
#
# - SOCKET: The name of an input socket (wsocket must be not None).
#           If the socket is multi input, it must be the first argument:
#               - header: *name
#               - call  : *name
#           If the socket is not multi input
#               - header: name=None
#               - call  : name=name
#
# - PARAM : it is the name of a param (param can be None). It can be fixed or not
#           If fixed:
#               - header: ""
#               - call  : name=name
#           If not fixed
#               - header: name='VALUE'
#               - call  : name=name
#
# - CLS   : it is the cls argument
#         : - header : cls
#         : - call   : ""
#
# - OTHER : Not a socket nor a param
#         : - header : ""
#         : - call   : ""


class Argument:
    def __init__(self, arg_type, name, is_self=False):

        self.arg_type = arg_type
        self.name     = name
        self.is_self  = is_self
    
    def __init__OLD(self, name, value, quote_str_value=True, is_self=False, wsocket=None, param=None, is_fixed=False):
        
        self.name  = name
        
        if isinstance(value, str) and quote_str_value:
            self.value = f"'{value}'"
        else:
            self.value = value
        
        self.is_self  = is_self
        self.wsocket  = wsocket
        self.param    = param
        self.is_fixed = is_fixed
        
    @classmethod
    def Socket(cls, name, wsocket, is_self=False):
        arg         = cls('SOCKET', name, is_self=is_self)
        arg.wsocket = wsocket
        arg.is_self = is_self
        return arg
        
    @classmethod
    def Param(cls, name, value, quote_str_value=True, param=None, is_fixed=False):
        arg = cls('PARAM', name)
        if isinstance(value, str) and quote_str_value:
            arg.value = f"'{value}'"
        else:
            arg.value = value

        arg.param    = param
        arg.is_fixed = is_fixed
        return arg
        
    @classmethod
    def Cls(cls):
        return cls('CLS', "cls")
    
    @classmethod
    def Other(cls, header_str="", call_str="", **kwargs):
        arg = cls('OTHER', None)
        arg.header_str = header_str
        arg.call_str   = call_str
        for k, v in kwargs:
            setattr(self, k, v)
        return arg
        
    @property
    def is_socket(self):
        return self.arg_type == 'SOCKET'
    
    @property
    def is_multi(self):
        if self.is_socket and not self.is_shared:
            return self.wsocket.is_multi_input
        else:
            return False
    
    @property
    def is_param(self):
        return self.arg_type == 'PARAM'

    @property
    def is_cls(self):
        return self.arg_type == 'CLS'
    
    @property
    def is_shared(self):
        return isinstance(self.wsocket, list)
    
    @property
    def sheader(self):
        
        if self.arg_type == 'CLS':
            return "cls"
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return f"self"
                else:
                    return f"{self.name}=None"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return ""
            else:
                return f"{self.name}={self.value}"
            
        elif self.arg_type == 'OTHER':
            return self.header_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

    @property
    def scall(self):

        if self.arg_type == 'CLS':
            return ""
        
        elif self.arg_type == 'SOCKET':
            if self.is_multi:
                if self.is_self:
                    return f"self, *{self.name}"
                else:
                    return f"*{self.name}"
            else:
                if self.is_self:
                    return f"{self.name}=self"
                else:
                    return f"{self.name}={self.name}"
        
        elif self.arg_type == 'PARAM':
            if self.is_fixed:
                return f"{self.name}={self.value}"
            else:
                return f"{self.name}={self.name}"
            
        elif self.arg_type == 'OTHER':
            return self.call_str
        
        else:
            raise RuntimeError(f"Unkwnon argument type: {self.arg_type}")

        
    @property
    def scomment(self):
        
        if self.arg_type in ['CLS', 'OTHER']:
            return ""
        
        s = f"{self.name:15s}: "
        if self.is_socket:
            if self.is_multi:
                s += "*"
            s += self.wsocket.class_name
            if self.is_self:
                s += " (self)"
        else:
            if self.param is None:
                s += f"{self.value} ({type(self.value).__name__})"
            else:
                s += str(self.value)
                if self.param.is_enum and not self.is_fixed:
                    s += f" in {self.param.short_values}"
                    
        return s
    
    @property
    def splug(self):
        if not self.is_socket or self.is_shared:
            return None
        
        s = f"self.plug({self.wsocket.index}, "
        if self.is_self:
            s += "self"
            if self.is_multi:
                s += f" *{self.wsocket.uname}"
            return s + ")"
        else:
            if self.is_multi:
                s += "*"
            return s + f"{self.wsocket.uname})"
        
# ---------------------------------------------------------------------------
# A list of Arguments

class Arguments(list):
    
    def add(self, arg):
        if arg.is_self or arg.is_cls:
            self.insert(0, arg)
            
        elif arg.is_multi:
            if len(self) == 0:
                self.append(arg)
            elif self[0].is_self:
                self.insert(1, arg)
            else:
                self.insert(0, arg)
                
        else:
            self.append(arg)
    
    def add_attribute_args(self, domain='POINT', data_type='FLOAT', fixed_domain=False):
        self.append(Argument('owner_socket', 'self',     is_fixed=True, quote_str_value = False))
        self.append(Argument('domain',        domain,    is_fixed=fixed_domain))
        self.append(Argument('data_type',     data_type, is_fixed=True))
        
    @property
    def sheader(self):
        s = ""
        for arg in self:
            sh = arg.sheader
            if sh != "":
                s += f", {sh}"
        if s != "":
            return s[2:]
        else:
            return s
        
    @property
    def scall(self):
        s = ""
        for arg in self:
            if arg.is_cls:
                continue
            
            if arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"
            
        for arg in self:
            if not arg.is_multi:
                sc = arg.scall
                if sc != "":
                    s += f", {sc}"

        if s != "":
            return s[2:]
        else:
            return s

    # ---------------------------------------------------------------------------
    # Check the order of the sockets arguments
    
    def check_order(self, bl_idname):

        order = INPUT_SOCKETS_ORDER.get(bl_idname)
        if order is None:
            return
        reorder = [None] * len(order)
        for arg in self:
            if not arg.is_socket:
                continue
            
            name = arg.wsocket.bsocket.name
            if name in order:
                reorder[order[name]] = arg
        
        for arg in reorder:
            if arg is not None:
                self.remove(arg)
            
        for arg in reversed(reorder):
            if arg is not None:
                self.insert(0, arg)

    # ---------------------------------------------------------------------------
    # Generate the comments in a node call
        
    def gen_comment(self, _i_):
        
        ok_sockets = True
        ok_params  = True
        ok_fixed   = False
        for arg in self:
            if arg.is_socket:
                if ok_sockets:
                    yield _0_
                    yield _i_ + "Sockets arguments"
                    yield _i_ + "-----------------"
                    ok_sockets = False
                yield _i_ + _indent_ + arg.scomment

            if arg.is_param:
                if arg.is_fixed:
                    ok_fixed = True
                else:
                    if ok_params:
                        yield _0_
                        yield _i_ + "Parameters arguments"
                        yield _i_ + "--------------------"
                        ok_params = False
                    yield _i_ + _indent_ + arg.scomment
                
        if ok_fixed:
            yield _0_
            yield _i_ + "Fixed parameters"
            yield _i_ + "----------------"

            for arg in self:
                if arg.is_param and arg.is_fixed:
                    yield _i_ + _indent_ + arg.scomment

# ====================================================================================================
# Socket wrapper

class WSocket:
    
    SOCKET_CLASSES = {
        'NodeSocketBool'        : ('Boolean',    '',             'BOOLEAN'), 

        'NodeSocketInt'         : ('Integer',    '',             'INT'), 
        'NodeSocketIntUnsigned' : ('Integer',    'Unsigned',     'INT'), 

        'NodeSocketFloat'       : ('Float',      '',             'FLOAT'), 
        'NodeSocketFloatFactor' : ('Float',      'Factor',       'FLOAT'),
        'NodeSocketFloatAngle'  : ('Float',      'Angle',        'FLOAT'), 
        'NodeSocketFloatDistance': ('Float',     'Distance',     'FLOAT'), 

        'NodeSocketVector'      : ('Vector',     '',             'FLOAT_VECTOR'), 
        'NodeSocketVectorEuler' : ('Vector',     'Rotation',     'FLOAT_VECTOR'),
        'NodeSocketVectorXYZ'   : ('Vector',     'xyz',          'FLOAT_VECTOR'), 
        'NodeSocketVectorTranslation' : ('Vector', 'Translation','FLOAT_VECTOR'), 

        'NodeSocketColor'       : ('Color',      '',             'FLOAT_COLOR'), 
        'NodeSocketString'      : ('String',     '',             'FLOAT_COLOR'), 

        'NodeSocketGeometry'    : ('Geometry',   '',              None), 

        'NodeSocketCollection'  : ('Collection', '',              None), 
        'NodeSocketImage'       : ('Image',      '',              None), 
        'NodeSocketMaterial'    : ('Material',   '',              None), 
        'NodeSocketObject'      : ('Object',     '',              None), 
        'NodeSocketTexture'     : ('Texture',    '',              None), 
        'NodeSocketVirtual'     : ('Virtual',    '',              None),
        }
        
    DATA_TYPES = {
        'INT'         : 'Integer',
        'RGBA'        : 'Color',
        'FLOAT_VECTOR': 'Vector',
        'FLOAT_COLOR' : 'Color',
    }
    
    DOMAIN_DATA_TYPES = {
        'Float'     : 'FLOAT',
        'Integer'   : 'INT',
        'Vector'    : 'FLOAT_VECTOR',
        'Color'     : 'FLOAT_COLOR',
        'Boolean'   : 'BOOLEAN'
    }

    def __init__(self, bsocket, index):
        self.bsocket    = bsocket
        self.index      = index
        self.uname      = self.name
        self.class_name = WSocket.SOCKET_CLASSES[self.bsocket.bl_idname][0]
        self.domain_data_type = WSocket.DOMAIN_DATA_TYPES.get(self.class_name)
        if self.class_name == 'Geometry':
            if self.name.lower() in ['mesh', 'points', 'instances', 'volume', 'spline', 'curve']:
                self.class_name = self.name.capitalize()
                
    def __repr__(self):
        return f"<{self.uname} ({self.class_name})>"
    
    @staticmethod
    def domain_data_type(bl_idname):
        return WSocket.SOCKET_CLASSES[bl_idname][2]
    
    @property
    def bl_idname(self):
        return self.bsocket.bl_idname
        
    @property
    def enabled(self):
        return self.bsocket.enabled
    
    @property
    def name(self):
        s = self.bsocket.name.lower().replace(' ', '_')
        if s == 'id':
            return 'ID'
        else:
            return s
    
    @property
    def is_multi_input(self):
        return self.bsocket.is_multi_input
    
    @property
    def is_output(self):
        return self.bsocket.is_output
    
# ---------------------------------------------------------------------------
# A list of WSockets

class WSockets(list):
    
    def __init__(self, bsockets):
        super().__init__()
        self.bsockets = bsockets
        for index, bsocket in enumerate(self.bsockets):
            if bsocket.bl_idname != 'NodeSocketVirtual':
                self.append(WSocket(bsocket, index))
            
        # ---------------------------------------------------------------------------
        # Sockets can have the same name. Two cases:
        # 1. HOMNYMS: They are of the same class
        #    Only for input sockets. It correspond to parameters of same types,
        #    for instance for an operation
        # 2. SHARED: They are not of the same class
        #    Only one of them can be enabled
        
        names = {}
        for wsock in self:
            if wsock.name in names:
                names[wsock.name].append(wsock)
            else:
                names[wsock.name] = [wsock]
                
        # ----- unames
        # - key   : the unique name shared between several sockets
        # - value : the list of wsockets it is shared among
                
        self.unames = {}
        for name, wsocks in names.items():
            if len(wsocks) == 1:
                self.unames[name] = wsocks[0]
            else:
                class_name = wsocks[0].class_name
                distinction = 'HOMONYMS'
                for wsock in wsocks:
                    if wsock.class_name != class_name:
                        self.unames[wsock.name] = wsocks
                        distinction = 'SHARED'
                        break
                    
                if distinction == 'HOMONYMS':
                    if wsocks[0].is_output:
                        raise RuntimeError("Big mistake !!!")
                    for i, wsock in enumerate(wsocks):
                        wsock.uname = f"{name}{i}"
                        self.unames[wsock.uname] = wsock
                        
        # ----- unames indices
        # - key     : the unique name
        # - value   : a dictionay giving the socket index from the driving
        #             parameter value
        # Initialized by the owner node by making vary the driving parameter
        # and by calling the method update_unames_indices
        #
        # Example:
        # unames_indices = {'from_value': {'FLOAT': 0, 'VECTOR': 2}, 'to_value': {'FLOAT': 1, 'VECTOR' : 3}}

        self.unames_indices = {}
        for uname in self.unames:
            self.unames_indices[uname] = {}
            
    # ----------------------------------------------------------------------------------------------------
    # The sockets which are shared according a driving parameter                 
                        
    @property
    def shared_sockets(self):
        sel = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                sel[uname] = wsocks
        return sel
    
    # ----------------------------------------------------------------------------------------------------
    # The node makes vary the driving parameter. At each change, it calls the following
    # method to update the unames_indices dictionary
        
    def update_unames_indices(self, param_value):
        for uname, wsocks in self.shared_sockets.items():
            for wsock in wsocks:
                if wsock.enabled:
                    if self.unames_indices[uname].get(param_value) is not None:
                        raise RuntimeError("Unconsistant, really !")
                    self.unames_indices[uname][param_value] = wsock.index
    

    # ----------------------------------------------------------------------------------------------------
    # Get the currently enabled sockets
    
    def enabled_sockets(self):
        wsockets = []
        for wsock in self:
            if wsock.enabled:
                wsockets.append(wsock)
        return wsockets
    
    # ====================================================================================================
    # Output sockets indices
    # Used to build the output_sockets property of the generated class
    
    def get_socket_indices(self, fixed):
        inds = {}
        for uname, wsocks in self.unames.items():
            if isinstance(wsocks, list):
                index = self.unames[uname][fixed[self.driving_param]]
            else:
                index = wsocks.index
            inds[uname] = index
        return inds
    
# ====================================================================================================
# A parameter wrapper

class Parameter:
    def __init__(self, wnode, name):
        self.wnode   = wnode
        self.name    = name
        self.uname   = name

        self.is_enum = False
        self.default = self.value
        self.param_type = type(self.default).__name__ 
        
        if isinstance(self.default, bpy.types.bpy_struct):
            self.default = None
        elif isinstance(self.default, mathutils.Vector):
            self.default = list(self.default)
        if isinstance(self.default, str):
            try:
                setattr(self.wnode.bnode, self.name, 'ERROR')
                #self.value = 'ERROR'
            except TypeError as e:
                msg = str(e)
                i = msg.find('enum "ERROR" not found in')
                self.is_enum = i > 0
                if self.is_enum:
                    self.values = eval(msg[i+26:])
                    
    @property
    def sdefault(self):
        if isinstance(self.default, str):
            return f"'{self.default}'"
        else:
            return self.default
        
    @property
    def value(self):
        return getattr(self.wnode.bnode, self.name)
    
    @value.setter
    def value(self, v):
        try:
            setattr(self.wnode.bnode, self.name, v)
        except:
            print(f"CAUTION: error when setting parameter {self.name} with value '{v}'")
        
    def reset(self):
        if self.default is not None:
            self.value = self.default
            
    @property
    def short_values(self):
        s = ""
        ok_pass = True
        for i, value in enumerate(self.values):
            if (len(s) < 30) or (i >= len(self.values)-3):
                s += f", {value}"
            else:
                if ok_pass:
                    s += ',... '
                    ok_pass = False
        return f"[{s[2:]}]"
        
            
# ====================================================================================================
# A node wrapper

class WNode:
    
    WNODES = {}
    
    STD_ATTRS = [
       '__doc__', '__module__', '__slots__', 'bl_description', 'bl_height_default', 'bl_height_max',
       'bl_height_min', 'bl_icon', 'bl_idname', 'bl_label', 'bl_rna', 'bl_static_type',
       'bl_width_default', 'bl_width_max', 'bl_width_min', 'color', 'dimensions', 'draw_buttons',
       'draw_buttons_ext', 'height', 'hide', 'input_template', 'inputs', 'internal_links',
       'is_registered_node_type', 'label', 'location', 'mute', 'name', 'output_template', 'outputs',
       'parent', 'poll', 'poll_instance', 'rna_type', 'select', 'show_options', 'show_preview',
       'show_texture', 'socket_value_update', 'type', 'update', 'use_clamp', 'use_custom_color',
       'width', 'width_hidden']
    
    def __init__(self, bnode):
        
        WNode.WNODES[bnode.bl_idname] = self
        
        self.bnode   = bnode
        self.inputs  = WSockets(self.bnode.inputs)
        self.outputs = WSockets(self.bnode.outputs)
        
        self.parameters = {}
        for param_name in dir(self.bnode):
            if not param_name in WNode.STD_ATTRS:
                param = Parameter(self, param_name)
                if param.default is None:
                    continue
                    
                self.parameters[param_name] = param
                if param_name in self.outputs.unames:
                    self.parameters[param_name].uname = param_name + '_'
                    
        # ----- shared sockets : a unique name is shared between several sockets
                    
        self.has_shared_sockets = bool(self.inputs.shared_sockets) or bool(self.outputs.shared_sockets)
        
        if self.has_shared_sockets:
            self.driving_param = 'input_type' if hasattr(self.bnode, 'input_type') else 'data_type'
            
            param = self.parameters[self.driving_param]
            for value in param.values:
                param.value = value
                self.inputs.update_unames_indices(value)
                self.outputs.update_unames_indices(value)

    def __str__(self):
        return f"[{self.node_name}]"
        
    @property
    def bl_idname(self):
        return self.bnode.bl_idname
    
    @property
    def node_name(self):
        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            if word.lower() == 'id':
                s += 'ID'
            else:
                s += word.capitalize()
        return s
        #return "Node" + s
    
    @property
    def function_name(self):
        words = self.bnode.name.split(' ')
        s = ""
        for word in words:
            w = word.lower()
            if w == 'id':
                w = 'ID'
            if w == '_':
                s += '_'
            else:
                if s != "":
                    s += '_'
                s += w
        return s
    
    # ---------------------------------------------------------------------------
    # Set parameters

    def reset_params(self):
        for param in self.parameters.values():
            param.reset()

    def set_params(self, param_values={}):
        for name, param in self.parameters.items():
            if name in param_values:
                param.value = param_values[name]
            else:
                param.reset()
                
    # ----------------------------------------------------------------------------------------------------
    # Non driving parameters
    
    def non_driving_params(self):
        params = {}
        for name, param in self.parameters.items():
            if name == self.driving_param:
                continue
            params[name] = Parameter(self, name)
        return params
    
    # ----------------------------------------------------------------------------------------------------
    # Node arguments
    
    def get_node_arguments(self):

        args = Arguments()
        for uname, wsock in self.inputs.unames.items():
            args.add(Argument.Socket(uname, wsocket=wsock))
            
        for name, param in self.parameters.items():
            args.append(Argument.Param(name, param.default, param=param))
            
        args.check_order(self.bl_idname)
            
        return args
    
    # ====================================================================================================
    # Enabled sockets with the fixed parameters
    # makes the free parameters vary to check which sockets to use
    
    def sockets_unames(self, wsockets, fixed={}):
    
        self.set_params(fixed)
        
        ens = [wsock.enabled for wsock in wsockets]
        for name, param in self.parameters.items():
            if name in fixed:
                continue
            if not param.is_enum:
                continue
            
            # ----- Reload the enum values to explore the possibilities
            
            new_param = Parameter(self, name)
            for value in new_param.values:
                param.value = value
                for i, wsock in enumerate(wsockets):
                    if wsock.enabled:
                        ens[i] = True
            new_param.value = new_param.default
        
        # ----- Let's keep only the outputs which can be enabled
        
        self.set_params(fixed)

        fixed_shared = True
        if self.has_shared_sockets:
            fixed_shared = self.driving_param in fixed
                
        unames = {}
        for i, wsock in enumerate(wsockets):
            if ens[i] and (wsock.uname not in unames):
                if fixed_shared or wsock.uname not in wsockets.shared_sockets:
                    unames[wsock.uname] = wsock.class_name
                else:
                    unames[wsock.uname] = f"{self.driving_param} dependant"
                    
        return unames

    # ----------------------------------------------------------------------------------------------------
    # Argument sockets

    def input_unames(self, fixed={}):
        return self.sockets_unames(self.inputs, fixed=fixed)
    
    # ----------------------------------------------------------------------------------------------------
    # Returned sockets
    
    def output_unames(self, fixed={}):
        return self.sockets_unames(self.outputs, fixed=fixed)
    
    # ====================================================================================================
    # Formatting utility
    
    @staticmethod
    def format_list(values, width=100, first_width=None):
        
        if not values:
            return "[]"
        
        is_str = isinstance(values[0], str)
        if first_width is None:
            first_width = width
        w = first_width
        s = "["
        sep = ""
        for i, value in enumerate(values):
            if is_str:
                s += f"{sep} '{value}'"
            else:
                s += "{sep} {str(value)}"
            if len(s) >= w:
                if i == len(values)-1:
                    yield s + "]"
                else:
                    yield s + ","
                s   = ""
                sep = ""
                w   = width
                
        if s != "":
            yield s + "]"
    
    # ====================================================================================================
    # Generate the node class
    
    def gen_node_class(self, wrap_parameters=True):
        
        args = self.get_node_arguments()
        
        # ---------------------------------------------------------------------------
        # Class header
        #
        # class NodeMath(Node):
        
        yield _0_ + f"class {self.node_name}(Node):\n"
    
        # ---------------------------------------------------------------------------
        # Class comment
    
        yield _1_ + '"""' + f"Node '{self.bnode.name}' ({self.bl_idname})\n"
    
        if self.has_shared_sockets:
            yield _1_ + "Data type dependant sockets"
            yield _1_ + "---------------------------\n"
            yield _2_ + f"Driving parameter : {self.driving_param} in {self.parameters[self.driving_param].values}\n"
            inds = self.inputs.shared_sockets
            if inds:
                yield _2_ + f"Input sockets     : {list(inds.keys())}"
            inds = self.outputs.shared_sockets
            if inds:
                yield _2_ + f"Output sockets    : {list(inds.keys())}"
            yield _0_
        
        if self.inputs:
            yield _1_ + "Input sockets"
            yield _1_ + "-------------"
            for uname, wsock in self.inputs.unames.items():
                yield _2_ + f"{uname:15s} : "
                if isinstance(wsock, list):
                    yield f"{self.driving_param} dependant"
                else:
                    if wsock.is_multi_input:
                        yield "*"
                    yield wsock.class_name
                    
            yield _0_
        
        if self.parameters:
            yield _1_ + "Parameters"
            yield _1_ + "----------"
            for name, param in self.parameters.items():
                yield _2_ + f"{name:15s} : "
                #stype = type(param.default).__name__
                stype = param.param_type
                sdef = f"'{param.default}'" if stype == 'str' else f"({param.default})"
                yield sdef
                
                if param.is_enum:
                    yield " in "
                    indent = ""
                    for line in self.format_list(param.values, 100):
                        yield indent + line
                        indent = _2_ + _indent_*5
                else:
                    yield " " + stype
            yield _0_
            
    
        if self.outputs:
            yield _1_ + "Output sockets"
            yield _1_ + "--------------"
            for uname, wsock in self.outputs.unames.items():
                yield _2_ + f"{uname:15s} : "
                if isinstance(wsock, list):
                    yield f"{self.driving_param} dependant"
                else:
                    yield wsock.class_name
                    if wsock.is_multi_input:
                        yield " (multi input)"
    
        yield _1_ + '"""' + "\n"
    
        # ---------------------------------------------------------------------------
        # Constructor __init__
        #
        # def __init__(self, input sockets, param sockets, label):
    
        yield _1_ + f"def __init__(self"
        s = args.sheader
        if s != "":
            yield ", " + s
        yield ", label=None):\n"
    
        # ---------------------------------------------------------------------------
        # Call of super
        #
        # super().__init__(bl_idname, name, label)
        
        yield _2_ + f"super().__init__('{self.bl_idname}', name='{self.bnode.name}', label=label)"

        # ---------------------------------------------------------------------------
        # Parameters
        #
        # self.bnode.data_type = data_type
        
        yield_comment = True
        if False:
            yield _2_ + f"self.parameters = ["
            sep = ""
            for name in self.parameters:
                yield f"{sep}'{name}'"
                sep = ", "
            yield "]"
        
        for name, param in self.parameters.items():
            if yield_comment:
                yield _2_ + "# Parameters\n"
                yield_comment = False
            
            yield _2_ + f"self.bnode.{param.name:15s} = {name}"
        
        if not yield_comment:
            yield "\n"
    
        # ---------------------------------------------------------------------------
        # Shared Input sockets
        # if the node has shared sockets, two loops:
        # - loop on the possible values of the driving parameter
        # - loop on the shared input sockets
        #
        # inputs.shared_sockets: {socket.uname: [wsockets...]}
        # inputs.unames_indices: {socket.uname: {param value: index}}
        #
        # if data_type == 'FLOAT':
        #     self.plug(0, value0)
        #     self.plug(2, value1)
        # elif data_type == 'VECTOR':
        #     self.plug(1, value0)
        #     self.plug(3, value1)
        
        yield_comment = True
        if self.has_shared_sockets:
            param = self.parameters[self.driving_param]
            sif = "if"
            for index, value in enumerate(param.values):
                yield_if = True
                for uname, valinds in self.inputs.unames_indices.items():
                    idx = valinds.get(value)
                    if idx is not None:
                        
                        if yield_comment:
                            yield _2_ + "# Input sockets\n"
                            yield_comment = False
                        
                        if yield_if:
                            yield _2_ + f"{sif} {self.driving_param} == '{value}':"
                            sif = "elif"
                            yield_if = False
                        yield _3_ + f"self.plug({idx}, {uname})"
            yield "\n"

        # ---------------------------------------------------------------------------
        # Other input sockets
        #
        # self.plug(4, factor)
        
        for arg in args:
            if not arg.is_socket or arg.is_shared:
                continue
            
            if yield_comment:
                yield _2_ + "# Input sockets\n"
                yield_comment = False
            
            yield _2_ + arg.splug

        if not yield_comment:
            yield "\n"
        
        # ---------------------------------------------------------------------------
        # Shared outputs sockets
        #
        # See shared input sockets
        #
        # if data_type == 'FLOAT':
        #     self.value = self.Float(self.bnode.outputs[0])
        # elif data_type == 'VECTOR':
        #     self.value = self.Vector(self.bnode.outputs[1])
        
        yield_comment = True
        if self.has_shared_sockets:
            param = self.parameters[self.driving_param]
            sif = "if"
            for index, value in enumerate(param.values):
                yield_if = True
                for uname, valinds in self.outputs.unames_indices.items():
                    idx = valinds.get(value)
                    if idx is not None:
                        
                        if yield_comment:
                            yield _2_ + "# Output sockets\n"
                            yield_comment = False
                        
                        if yield_if:
                            yield _2_ + f"{sif} {self.driving_param} == '{value}':"
                            sif = "elif"
                            yield_if = False
                        yield _3_ + f"self.{uname:15s} = self.{self.outputs[idx].class_name}(self.bnode.outputs[{idx}])"

            yield "\n"
        
        # ---------------------------------------------------------------------------
        # Other output sockets
        #
        # self.fac = self.Float(self.bnode.outputs[2])
        
        socks = []
        for wsocket in self.outputs:
            
            if not wsocket.uname in socks:
                socks.append(wsocket.uname)
                
            if wsocket.uname in self.outputs.shared_sockets:
                continue
            
            if yield_comment:
                yield _2_ + "# Output sockets\n"
                yield_comment = False
            
            idx = wsocket.index
            yield _2_ + f"self.{wsocket.uname:15s} = self.{self.outputs[idx].class_name}(self.bnode.outputs[{idx}])"
            
        yield _2_ + "self.output_sockets  = {"
        sep = ""
        for sock in socks:
            yield f"{sep}'{sock}': self.{sock}"
            sep = ", "
        yield "}"

        yield "\n"
    
        # ---------------------------------------------------------------------------
        # Wrap the parameters
        
        if wrap_parameters:
            for name, param in self.parameters.items():
                yield _1_ +  "@property"
                yield _1_ + f"def {param.uname}(self):"
                yield _2_ + f"return self.bnode.{name}\n"
            
                yield _1_ + f"@{param.uname}.setter"
                yield _1_ + f"def {param.uname}(self, value):"
                yield _2_ + f"self.bnode.{name} = value\n"
    
    
    # ====================================================================================================
    # Generate a call
    
    def gen_call(self, family, class_name, meth_name, self_name=None, settable=False, properties=None, attribute={}, **fixed):
        
        #print("GEN_CALL:", self.node_name, family, class_name, meth_name, self_name)
        #print()
        
        _indent_, _0_, _1_, _2_, _3_, _4_ = indent_set(-1 if family == 'FUNCTION' else 0)

        # ---------------------------------------------------------------------------
        # Configure the node to steer the enablement

        self.set_params(fixed)
        
        # ---------------------------------------------------------------------------
        # Dictionary : {uname : class_name}
        # of the input / ouput sockets in this configuration
        
        inp_unames = self.input_unames(fixed)
        ret_unames = self.output_unames(fixed)
        
        # ---------------------------------------------------------------------------
        # If self_name is None, use the first enabled input socket of the proper class

        if family in ['FUNCTION', 'STATIC', 'CLASS', 'CONSTRUCTOR', 'ATTRIBUTE', 'CAPT_ATTR']:
            if self_name is not None:
                raise RuntimeError(f"The method {meth_name} on node {self.node_name} is {family}: it can have a self argument: {self_name}.")
                
        elif self_name is None and self.inputs:
            geo_socket = None
            for wsock in self.inputs:
                #print(class_name, wsock.uname, wsock.class_name, wsock.enabled)
                if wsock.enabled:
                    if wsock.class_name == class_name:
                        self_name = wsock.uname
                        break
                    if wsock.class_name == 'Geometry' and geo_socket is None:
                        geo_socket = wsock.class_name
                    
            if self_name is None:
                if class_name in ['Mesh', 'Points', 'Instances', 'Volume', 'Curve', 'Spline'] and geo_socket is not None:
                    self_name = geo_socket
                else:
                    raise RuntimeError(f"The method {meth_name} on node {self.node_name} is {family}: it requires a self argument for class {class_name}.")
                
        # ---------------------------------------------------------------------------
        # Arguments
        
        args     = Arguments()
        arg_self = False
        arg_mult = False

        if family in ['CAPT_ATTR', 'ATTRIBUTE']:
            args.add(Argument.Other(header_str="self", call_str=""))
            arg_self = True
            
        #for uname, wsocks in self.inputs.unames.items():
        for uname in inp_unames:
            wsocks = self.inputs.unames[uname]
            
            wsock = None
            if isinstance(wsocks, list):
                for ws in wsocks:
                    if ws.enabled:
                        wsock = ws
                        break
            else:
                wsock = wsocks
                
            if wsock is None:
                continue
                
            is_self  = uname == self_name
            args.add(Argument.Socket(uname, wsocket=wsock, is_self=is_self))
            
        for name, param in self.parameters.items():
            is_fixed = name in fixed
            value = fixed[name] if is_fixed else param.default
            args.append(Argument.Param(name, value, param=param, is_fixed=is_fixed))
            
        if family == 'PROPERTY':
            args.add(Argument.Other(header_str="", call_str="label=f\"{self.node_chain_label}." + meth_name + "\""))

        if family == 'CAPT_ATTR':
            args.add(Argument.Other(header_str=f"domain='{attribute['domain']}'"))

        # ----- Ensure the socket arguments are properly ordered
        
        args.check_order(self.bl_idname)
            
        # ----------------------------------------------------------------------------------------------------
        # Function header
        #
        # @decorator
        # def method(self, args...):
        
        # ----- Static method
        # @staticmethod
        # def method(args,...):
        
        is_cls = False
        if family in 'STATIC':
            yield _1_ + "@staticmethod"

        # ----- Class method
        # @classmethod
        # def method(cls, args,...):

        elif family in ['CLASS', 'CONSTRUCTOR']:
            yield _1_ + "@classmethod"
            args.add(Argument.Cls())
            is_cls = True

        # ----- Property
        # @property
        # def method(self, args,...):

        elif family == 'PROPERTY':
            yield _1_ + "@property"
        
        elif family == 'ATTRIBUTE':
            #if len(ret_unames) == 1 and not attribute['capture']:
            if not attribute['capture']:
                yield _1_ + "@property"
                

        # ----- Other
        # def method(self, args,...):
        
        yield _1_ + f"def {meth_name}({args.sheader}):"
        
        # ----------------------------------------------------------------------------------------------------
        # Comment
        
        yield _2_ + '"""' + f"Call node {self.node_name} ({self.bl_idname})"
        for line in args.gen_comment(_2_):
            yield line
    
        yield _0_
        yield _2_ + "Returns"
        yield _2_ + "-------"
        
        if family == 'STACK':
            yield _3_ + "self\n"
        
        elif family == 'ATTRIBUTE':
            yield _3_ + ret_unames[list(ret_unames)[attribute['output_index']]]

        else:
            if len(ret_unames) == 0:
                yield _3_ + f"self\n"

            elif len(ret_unames) == 1:
                yield _3_ + ret_unames[list(ret_unames)[0]]
            
            else:
                yield _3_ + "Sockets ["
                sep = ""
                for uname in ret_unames:
                    yield f"{sep}{uname} ({ret_unames[uname]})"
                    sep = ", "
                yield "]"
        
        yield _2_ + '"""' + "\n"
    
        # ----------------------------------------------------------------------------------------------------
        # Node call string
        
        snode_call = f"nodes.{self.node_name}({args.scall})"
            
        # ----------------------------------------------------------------------------------------------------
        # ----- Call and return

        # ----------------------------------------------------------------------------------------------------
        # STACK: call the stack with the node
        #
        # def method(self, ...):
        #     return self.stack(node(...))
    
        if family == 'STACK':
            yield _2_ + f"return self.stack({snode_call})\n"
    
        # ----------------------------------------------------------------------------------------------------
        # PROPERTY: create a local attribute plus create children properties
        # if the resulting node has several sockets:
        #
        # @property
        # def length(self):
        #     if self.length_ is None:
        #         self.length_ = Node(...).length
        #     return self.length_
        #
        # or
        #
        # @property
        # def components(self):
        #     if self.components is None:
        #         self.components_ = Node(...)
        #     return self.components_
        #
        # @property
        # def mesh_component(self):
        #     return self.components.mesh
        #
        # @property
        # def curve_component(self):
        #     return self.components.curve
    
        elif family == 'PROPERTY':
            
            settable   = properties['settable']
            prop_names = properties['names']
            
            if len(ret_unames) == 0:
                raise RuntimeError(f"Impossible to implement a property on {self.node_name} with not output sockets!")
                
            yield _2_ + f"if self.{meth_name}_ is None:"
            yield _3_ + f"self.{meth_name}_ = {snode_call}"
        
            if len(ret_unames) == 1:
                yield f".{list(ret_unames)[0]}"
            yield _2_ + f"return self.{meth_name}_\n"
        
            if len(ret_unames) > 1:
                yield "\n"
                if prop_names is None:
                    prop_names = ret_unames
                for uname, pname in zip(ret_unames, prop_names):
                    yield _1_ + "@property"
                    yield _1_ + f"def {pname}(self):"
                    yield _2_ + f"return self.{meth_name}.{uname}\n"
            
                    if settable:
                        yield _1_ +f"@{pname}.setter"
                        yield _1_ + f"def {pname}(self, value):"
                        yield _2_ + f"self.{meth_name}.{uname} = value\n"
                    
        # ----------------------------------------------------------------------------------------------------
        # ATTRIBUTE: the attribute dictionary contains:
        # - capture      : False or True if if is the implementation of the captur_attr method
        # - capture_meth : Name of the capture_attr method (when capture is False) 
        # - domain       : The attribute domain
        # - output_index : The index of the output socket
        #
        # Implementation depends upon the capture value
        # True:  The capture method with domain argument to cover all the possible domains
        # False: Property with a specific domain
        #
        # ----- capture = True:
        # 
        # def capture_attr(self, domain='POINT'):
        #      node = nodes.NodeAttr()
        #      node.as_atribute(owning_socket=self, domain=domain)
        #      return node.socket # When only one output socket
        #      return node        # When several output sockets
        #
        # ----- capture = False
        #
        # @property
        # def point_attr(self, domain='POINT'):
        #      return self.capture_attr(domain=domain)
        #
        # If the attribute has several output sockets (GeometryNodeInputMeshIsland returns island_vertex and island_count),
        # each output socket is implemented. The names are provided in prop_names which is mandatory
        #
        # @property
        # def point_attr_socket(self):
        #      return self.capture(domain='POINT').output_sockets[output_index]

        elif family == 'CAPT_ATTR':
            yield _2_ + f"attr_name = '{meth_name}_' + domain" 
            yield _2_ +  "if not hasattr(self, attr_name):"
            yield _3_ + f"node = {snode_call}"
            yield _3_ +  "node.as_attribute(owning_socket=self, domain=domain)"
            yield _3_ +  "setattr(self, attr_name, node)"
        
            if len(ret_unames) == 1:
                yield _2_ + f"return getattr(self, attr_name).{list(ret_unames)[0]}\n"
            else:
                yield _2_ +  "return getattr(self, attr_name)\n"
        
        elif family == 'ATTRIBUTE':
            if len(ret_unames) == 1:
                yield _2_ + f"return self.{attribute['capture_meth']}(domain='{attribute['domain']}')\n"
            else:             
                yield _2_ + f"return self.{attribute['capture_meth']}(domain='{attribute['domain']}').{list(ret_unames)[attribute['output_index']]}\n"
                #yield _2_ + f"return self.{attribute['capture_meth']}(domain='{attribute['domain']}').output_sockets[{attribute['output_index']}]\n"
    
                
        # ----------------------------------------------------------------------------------------------------
        # Other : can return 3 things depending on the number of output sockets in ret_unames
        #
        # 0. no socket   : return None
        # 1. 1 socket    : return the socket
        # 2: > 1 sockets : return the node
        #
        # def method(self,...):
        #     Node(...)
        #
        # def method(self,...):
        #     return Node(...).mesh
        #
        # def method(self,...):
        #     return Node(...)
    
        else:
            if len(ret_unames) == 0:
                yield _2_ + f"{snode_call}\n"
            
            elif len(ret_unames) == 1:
                if is_cls:
                    yield _2_ + f"return cls({snode_call}.{list(ret_unames)[0]})\n"
                else:
                    yield _2_ + f"return {snode_call}.{list(ret_unames)[0]}\n"
            
            else:
                yield _2_ + f"return {snode_call}\n"
        
        
# ====================================================================================================
# Generate the nodes module

def create_nodes_module(fname):
    with open(fname, 'w') as f:
        f.write("from geonodes.core.node import Node\n")
        
        for bnode in BNODES.values():
            wn = WNode(bnode)
            
            """
            if wn.has_shared_sockets:
                sblid = f"'{wn.bl_idname}'"
                print(f"    {sblid:32s} : '{wn.function_name}', # {wn.parameters[wn.driving_param].values}")
                dprm = wn.parameters[wn.driving_param]
                for value in dprm.values:
                    print('---', value)
                    dprm.value = value
                    prms = wn.non_driving_params()
                    for n, p in prms.items():
                        if p.is_enum:
                            print(f"   {n:15s} : {p.values}")
                    print()
                print()
            """
            
            if wn.bl_idname in ['NodeReroute', 'NodeGroupInput', 'NodeGroupOutput', 'GeometryNodeViewer', 'NodeFrame']:
                logger.info(f"Ignore: {wn.bl_idname}")
                continue
            
            f.write(f"\n# {'-'*100}\n")
            f.write(f"# Node {wn.node_name} for {wn.bl_idname}\n")

            for line in wn.gen_node_class():
                f.write(line)
                
def gen_geonodes(fpath=None):

    fpath = "/Users/alain/Documents/blender/scripts/modules/geonodes/"
    
    # ----- nodes.py

    create_nodes_module(fpath + "nodes/nodes.py")
    #create_nodes_module("/Users/alain/Documents/blender/scripts/modules/geonodes/nodes/nodes.py")

    # ----- sockets files

    gsock.GEN_NODES = []

    for i, dgen in enumerate(gsock.DATA_CLASSES):
        
        class_gen = dgen(WNode.WNODES)
        
        #with open(get_folder("sockets").joinpath(f"{class_gen.class_name.lower()}.py"), 'w') as f:
        with open(fpath + f"sockets/{class_gen.class_name.lower()}.py", 'w') as f:

            for line in class_gen.gen_class():
                f.write(line)
                
            f.write("\n\n")
                
                
"""                    
            

create_nodes_module("/Users/alain/Documents/blender/scripts/modules/geonodes/nodes/nodes.py")

gsock.GEN_NODES = []

for i, dgen in enumerate(gsock.DATA_CLASSES):
    
    class_gen = dgen(WNode.WNODES)
    
    fpath = "/Users/alain/Documents/blender/scripts/modules/geonodes/sockets/"
    
    #with open(get_folder("sockets").joinpath(f"{class_gen.class_name.lower()}.py"), 'w') as f:
    with open(fpath + f"{class_gen.class_name.lower()}.py", 'w') as f:

        for line in class_gen.gen_class():
            f.write(line)
            
        f.write("\n\n")
        
"""
            

    